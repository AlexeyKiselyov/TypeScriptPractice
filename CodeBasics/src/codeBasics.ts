// --------->4th task
const getEvenNumbers = (arr: number[]): number[] => {
  return arr.filter(number => number % 2 === 0);
};

const numbers1 = [1, 3, 8, 9, 100, 23, 55, 34];
console.log(getEvenNumbers(numbers1));

// --------->5th task
function filterAnagrams(str: string, arr: string[]): string[] {
  const etalon = str.toUpperCase().split('').sort().join('');
  return arr.filter(
    item => etalon === item.toUpperCase().split('').sort().join('')
  );
}

// --------->6th task
function isComplete(course: { name: string; lessons: string[] }): boolean {
  return course.lessons.length > 3;
}

// --------->7th task
enum ModalStatus {
  Opened,
  Closed,
}

const buildModal = (
  text: string,
  status: ModalStatus
): { text: string; status: ModalStatus } => {
  return { text, status };
};

// --------->8th task
type User = {
  name: string;
  age: number;
};

const getOlderUser = (user1: User, user2: User): User | null => {
  if (user1.age > user2.age) return user1;
  if (user2.age > user1.age) return user2;
  return null;
};

// --------->9th task
const getParams = (params: string): any => {
  const arrOfParams = params.split('&');
  const initial: any = {};

  return arrOfParams.reduce((acc, item) => {
    const [key, value] = item.split('=');
    acc[key] = value;
    return acc;
  }, initial);
};

// example
console.log(getParams('per=10&page=5'));

// --------->11th task

namespace Company {
  export function isEmployeeEmail(
    email: string,
    companyDomain: string
  ): boolean {
    const [_, userDomain] = email.split('@');

    return userDomain === companyDomain;
  }
}

type User1 = {
  email: string;
};

function authorize(user: User1 | null): boolean {
  const companyDomain = 'hexlet.io';

  const email = user?.email ?? '';

  return Company.isEmployeeEmail(email, companyDomain);
}

// --------->13th task
function map(
  arr: number[],
  callback: (n: number, index: number) => number
): number[] {
  const result: number[] = [];
  arr.forEach((numb, index) => {
    result.push(callback(numb, index));
  });
  return result;
}

// --------->14th task

function forEach(
  arr: number[],
  callback: (n: number, index: number) => void
): void {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}

// --------->15th task
function fail1(message: string): never {
  throw new Error(message);
}

function fail2(): never {
  while (true) {
    console.log('infinity loop');
  }
}

// function fail3(code: number = 0): never {
//   process.exit(code);
// }

// function fail4(): never {
//   return exit(1);
// }

// --------->16th task
function isPlainObject(value: unknown): boolean {
  return value instanceof Object && !Array.isArray(value);
}

// --------->17th task ---> Destructurization

type Course = {
  lessons: string[];
};

function lessonsCount({ lessons }: Course): number {
  return lessons.length;
}

// --------->18th task ---> Rest Ð¸ Spread
function max(num: number, ...numbers: number[]): number {
  return Math.max(num, ...numbers);
}

// --------->19th task ---> Function Overloads
type NewYearCongratulate = {
  (name: string): string;
  (year: number, name: string): string;
};

const newYearCongratulate: NewYearCongratulate = (
  data1: string | number,
  data2?: string
): string => {
  if (data2) {
    return `Hi ${data2}! Happy New Year ${data1}!`;
  } else {
    return `Hi ${data1}! Happy New Year!`;
  }
};

// --------->20th task ---> Type Narrowing, Type Guard
function last(value: string | number): string | number {
  if (typeof value === 'number') {
    return value % 10;
  }

  return value[value.length - 1] ?? '';
}

function isPresence(value: unknown): boolean {
  if (value === null || value === undefined) {
    return false;
  }
  // empty string
  if (typeof value === 'string') {
    if (value === '') {
      return false;
    }
  }
  // empty array
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return false;
    }
  }
  // empty object
  if (value instanceof Object) {
    if (Object.keys(value).length === 0) {
      return false;
    }
  }

  return true;
}

function foo(value: number | string) {
  switch (typeof value) {
    case 'number':
      // ...
      break;
    case 'string':
      // ...
      break;
  }
}

function isObject(value: unknown): value is object {
  return typeof value === 'object' && value !== null;
}

// --------->21th task ---> Type Annotations
// 1
function unique(arr: (number | string)[]): (number | string)[] {
  return [...new Set(arr)];
}

// 2
type User2 = {
  name: string;
};

const users: User2[] = [];

function foo1(users: User2[]) {
  return users;
}

// 3
const users1: { name: string }[] = [];
const users2: (string | null)[] = [];
const users3: (User2 | null | { name: string })[] = [];

// 4
const users4: Array<User> = [];
const users5: Array<number> = [];
const users6: Array<User> = [];

const users7: Array<{ name: string }> = [];
const users8: Array<string | null> = [];

// --------->22th task ---> Multidimensional Arrays

// 1
// first option
function getField(size: number): null[][] {
  const field = Array<null>(size)
    .fill(null)
    .map(() => Array<null>(size).fill(null));
  return field;
}

// second option
function getField1(size: number): null[][] {
  const field: null[][] = [];
  for (let i = 0; i < size; i++) {
    const row = [];
    for (let j = 0; j < size; j++) {
      row.push(null);
    }
    field.push(row);
  }

  return field;
}

// 2
const items1 = [
  [3, 8],
  [10, 4, 8],
];

const items2: number[][] = [];

type User3 = {
  name: string;
};

const users9: User3[][] = [[{ name: 'Eva' }, { name: 'Adam' }]];

// 3
const coll: (string | number)[][] = [];
coll.push(['hexlet', 5]);

// 4
const coll1: Array<Array<string | number>> = [];
coll1.push(['hexlet', 5]);

// 5
type Course1 = {
  name: string;
  lessons: Lesson[];
};

type Lesson = {
  name: string;
  links: string[];
};

// --------->23th task ---> Readonly Arrays

// first option
function reverse(arr: ReadonlyArray<number>): Array<number> {
  return arr.map((_, index) => arr[arr.length - 1 - index]);
}

// second option
function reverse1(arr: readonly number[]): Array<number> {
  const result: Array<number> = [];
  arr.forEach(numb => result.unshift(numb));
  return result;
}

// third option
function reverse3(arr: ReadonlyArray<number>): Array<number> {
  return arr.reduceRight((acc, numb) => {
    acc.push(numb);
    return acc;
  }, [] as number[]);
}

// --------->24th task ---> Tuples (can push)

type HTTPResponse = [number, string?]; //can be with optional param

type Point = [number, number, number];

function isTheSamePoint(point1: Point, point2: Point): boolean {
  return point1.every((numb, ind) => numb === point2[ind]);
}

// --------->25th task ---> Types as a set

type CustomType = null | undefined | number;

// --------->26th task ---> Union Types

// 1
type AllowedToConcatenation = number | string | null | undefined | boolean;

const concat = (
  base: AllowedToConcatenation,
  suffix: AllowedToConcatenation
): string => `${base}${suffix}`;

// 2
function lastIndex(str: string, char: string): number | null {
  const result = str.lastIndexOf(char);
  return result < 0 ? null : result;
}

// --------->27th task ---> Null and Undefined

function formatPrice(price?: number | null): string {
  if (price === undefined || price === null) {
    return '$0.00';
  }

  return `$${price.toFixed(2)}`;
}

// --------->28th task ---> Literal Types

type Hexlet = 'hexlet';
type One = 1;
type False = false;
type BigN = 100n;

// Literal Types Union

type OrderStatus = 'Created' | 'Paid' | 'Shipped' | 'Delivered';

type NumberFalse = number | false;

// String enums

enum OrderStatus1 {
  Created = 'Created',
  Paid = 'Paid',
  Shipped = 'Shipped',
  Delivered = 'Delivered',
}

// Literal Object

type DataSourceOption = {
  type: 'postgre' | 'mysql';
  host: string;
  port: number;
};

// Literary reduction

const ormConfig = {
  type: 'mysql',
  host: 'localhost',
  port: 5432,
} as const;

const str = 'test' as const;
type Str = typeof str; // 'test'

// Example
type Turtle = 'turtle' | null;

type Game = {
  makeTurn: (direction: 'left' | 'right') => void;
  state: Array<Turtle>;
};

const startGame = (): Game => {
  const state: Array<Turtle> = ['turtle', null, null, null, null];
  const stateLength = 4;

  const makeTurn = (direction: 'left' | 'right'): void => {
    const turtleIndex = state.indexOf('turtle');
    const nextIndex = direction === 'left' ? turtleIndex - 1 : turtleIndex + 1;

    if (nextIndex < 0 || nextIndex > stateLength) {
      throw new Error('Out of bounds');
    }

    state[turtleIndex] = null;
    state[nextIndex] = 'turtle';
  };

  return { makeTurn, state };
};

// --------->29th task ---> Intersections Types
enum Permission {
  READ,
  WRITE,
  DELETE,
}

type User4 = {
  login: string;
};

type AdminPermission = {
  permission: Permission;
};

type Admin = User4 & AdminPermission;

const addAdmin = (user: User4): Admin => ({
  ...user,
  permission: Permission.READ,
});

// --------->30th task ---> Assignability //can be  Error: Type X is not assignable to type Y..

type Form = {
  age: {
    value: number;
    validator: (val: number) => boolean;
  };
  name: {
    value: string;
    validator: (val: string) => boolean;
  };
};

const form: Form = {
  name: {
    value: 'Mark',
    validator: (val: string) => val.length > 1,
  },
  age: {
    value: 16,
    validator: (val: number) => val > 18,
  },
};

// --------->31th task --->Type hierarchy

// Types as subsets
type ComparatorCallback = (
  item1: number,
  item2: number,
  index: number
) => -1 | 0 | 1;
declare function sort(
  arr: Array<number>,
  callback: ComparatorCallback
): Array<number>;

const arr = [1, 2, 3];
const comparator = (item1: number, item2: number) => Math.sign(item1 - item2);

// sort(arr, comparator); // Error: Type 'number' is not assignable to type '0 | 1 | -1'.

// Literary types
let num: number = 1;
const two: 2 = 2;
const notTrue: false = false;

num = two;
// num = notTrue; // Type 'boolean' is not assignable to type 'number'.

// unknown
// 1
let unknownValue: unknown = 1;

unknownValue = 2; // OK
unknownValue = false; // OK
unknownValue = 'string'; // OK

// 2
let unknownValue1: unknown;

unknownValue = 'string';
// unknownValue1toUpperCase(); // Error: Property 'toUpperCase' does not exist on type 'unknown'.

type UnionWithUnknown = unknown | number | boolean; //type will be unknown

// never
let neverValue: never;
const two1: 2 = 2;

// neverValue = two1; // Type 'number' is not assignable to type 'never'

// multiple types
type NumberUnion = -2 | -1 | 1 | 2;

const one: NumberUnion = 1;
const num1: number = one;

type StringUnion = 'a' | 'b' | 'c' | 'd';

const aChar: StringUnion = 'a';
const str1: string = aChar;

// Typing
// 1
let num2 = 1; // ÐÐµÑÐ²Ð½Ð¾Ðµ Ð²Ð¾ÑÑÐ¾Ð´ÑÑÐµÐµ Ð¿ÑÐ¸Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ
let one2: number = 1; // Ð¯Ð²Ð½Ð¾Ðµ Ð²Ð¾ÑÑÐ¾Ð´ÑÑÐµÐµ Ð¿ÑÐ¸Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ

let two2 = num2 as 2; // Ð¯Ð²Ð½Ð¾Ðµ Ð½Ð¸ÑÑÐ¾Ð´ÑÑÐµÐµ Ð¿ÑÐ¸Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ

let three2 = 3 as const; // ÐÑÐ¸Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ Ðº Ð»Ð¸ÑÐµÑÐ°Ð»ÑÐ½Ð¾Ð¼Ñ ÑÐ¸Ð¿Ñ â Ð½Ð¸ÑÑÐ¾Ð´ÑÑÐµÐµ

// 2
const args = [8, 5]; // args: number[]
// const angle = Math.atan2(...args); // error! A spread argument must either have a tuple type or be passed to a rest parameter.
// console.log(angle);

const args1 = [8, 5] as const; // readonly [8, 5]
const angle = Math.atan2(...args1); // okay
console.log(angle);

// example
type User5 = {
  id: number;
  name: string;
  age: number;
};

type Friends = [number, number];

export type UserResponse = {
  users: User5[];
  friends: Friends[];
};

// first option
function getUserFriends(userJson: string, userId: number): User5[] {
  const userData: UserResponse = JSON.parse(userJson);

  const friends = userData.friends.reduce((acc, item) => {
    const [id1, id2] = item as Friends;
    if (id1 === userId || id2 === userId) {
      const friendId = id1 === userId ? id2 : id1;
      const userFriend = userData.users.filter(({ id }) => friendId === id);
      if (userFriend.length > 0) {
        acc = [...acc, ...userFriend];
      }
    }
    return acc;
  }, [] as User5[]);

  return friends;
}

// second option
const defaultUser = { id: 0, name: '', age: 0 };
const getUserFriends1 = (userResponseJSON: string, userId: number): User5[] => {
  const userResponse = JSON.parse(userResponseJSON) as UserResponse;

  return userResponse.friends
    .map(([ownerId, friendId]: Friends): User5 => {
      if (!(userId === ownerId || userId === friendId)) return defaultUser;
      const searchId = ownerId === userId ? friendId : ownerId;
      const friend: User5 | undefined = userResponse.users.find(
        ({ id }) => id === searchId
      );

      return friend === undefined ? defaultUser : friend;
    })
    .filter((user: User5) => user.id > 0);
};

// --------->32th task --->Structural typing
type IntersectionUser = {
  username: string;
  password: string;
} & {
  type: string;
};

const admin: IntersectionUser = {
  // ÑÑÐµÐ±ÑÐµÑÑÑ ÑÐ¾Ð²Ð¿Ð°Ð´ÐµÐ½Ð¸Ðµ c Ð¾Ð±ÑÐµÐºÑÐ½ÑÐ¼ ÑÐ¸Ð¿Ð¾Ð¼ Ð¸ ÑÐ»ÐµÐ²Ð° Ð¸ ÑÐ¿ÑÐ°Ð²Ð° Ð¾Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÐ° &
  username: 'test',
  password: 'test',
  type: 'admin',
};

type UnionUser =
  | {
      username: string;
      password: string;
    }
  | {
      type: string;
    };

const user: UnionUser = { username: 'test', type: 'user' }; // Ð´Ð¾ÑÑÐ°ÑÐ¾ÑÐ½Ð¾ ÑÐ¾Ð²Ð¿Ð°Ð´ÐµÐ½Ð¸Ñ Ñ Ð¾Ð´Ð½Ð¸Ð¼ Ð¸Ð· Ð¾Ð±ÑÐµÐºÑÐ½ÑÑ ÑÐ¸Ð¿Ð¾Ð²

// example
enum LoadingStatus {
  Loading = 'Loading',
  Error = 'Error',
  Success = 'Success',
}
type DataState =
  | {
      status: LoadingStatus.Loading;
    }
  | {
      status: LoadingStatus.Error;
      error: Error;
    }
  | {
      status: LoadingStatus.Success;
      data: number;
    };

function handleData(dataState: DataState): string {
  if (dataState.status === LoadingStatus.Loading) {
    return 'loading...';
  }
  if (dataState.status === LoadingStatus.Error) {
    return dataState.error.message;
  }
  if (dataState.status === LoadingStatus.Success) {
    return String(dataState.data);
  }
  return 'unknown';
}

const loading: DataState = { status: LoadingStatus.Loading };
console.log(handleData(loading)); // loading...

const error: DataState = {
  status: LoadingStatus.Error,
  error: new Error('error'),
};
console.log(handleData(error)); // error

const success: DataState = { status: LoadingStatus.Success, data: 42 };
console.log(handleData(success)); // '42'

// --------->33th task --->Covariance and Contravariant

// --->First example
type ComparatorCallback1 = (item1: number, item2: number) => -1 | 0 | 1;
declare function sort(
  arr: Array<number>,
  callback: ComparatorCallback1
): Array<number>;

const arr1 = [1, 2, 3];
// 1st comparator variant with Error
const comparator1 = (item1: number, item2: number) => Math.sign(item1 - item2); // make error, because result of Math not '-1 | 0 | 1' => (item1: number, item2: number) => number;

//sort(arr, comparator1); // Error: Type 'number' is not assignable to type '0 | 1 | -1'.

// 2nd comparator variant withour Error
const comparator2 = (item1: number, item2: number) => {
  // (item1: number, item2: number) => -1 | 0 | 1;
  if (item1 === item2) {
    return 0;
  }

  return item1 > item2 ? 1 : -1;
};

// ---->Second example
type Formatter = (val: string) => string;

const formatToConcrete: Formatter = (): 'test' => 'test';
//const formatToNumber: Formatter = (val: '1') => val; // Error!

// ---->Practic
type Transaction = {
  apply: (amount: number) => number;
};

type Wallet = {
  transactions: Array<Transaction>;
  balance: number;
};

function applyTransactions(wallet: Wallet): number {
  try {
    let balance: number = wallet.balance;

    wallet.transactions.forEach(({ apply }) => {
      balance = apply(balance);
    });

    return balance;
  } catch (error) {
    return wallet.balance;
  }
}

// --------->34 tasks ---> Classes

type CustomSize = {
  name: string;
  size: number;
};

class CustomFile {
  name: string;
  size: number;

  constructor({ name, size }: CustomSize) {
    this.name = name;
    this.size = size;
  }

  toString(): string {
    return `${this.name} (${this.size} bytes)`;
  }
}

// --------->35 tasks ---> Classes as types

class Point1 {
  private x: number;

  private y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }

  isEqual(p2: Point1): boolean {
    return this.x === p2.x && this.y === p2.y;
  }
}

const point = new Point1(1, 2);
point.isEqual(new Point1(10, 1)); // OK
//point.isEqual({ x: 1, y: 2}); // Error: Argument of type '{ x: number; y: number; }' is not assignable to parameter of type 'Point'.

// practic
class CustomFile1 {
  name: string;
  size: number;
  isCopy: boolean;

  constructor(option: { name: string; size: number }) {
    this.name = option.name;
    this.size = option.size;
    this.isCopy = option instanceof CustomFile;
  }

  toString() {
    if (this.isCopy) {
      return `(copy) ${this.name} (${this.size} bytes)`;
    } else {
      return `${this.name} (${this.size} bytes)`;
    }
  }
}

const file = new CustomFile1({ name: 'open-world.jpeg', size: 1000 });
console.log(file.toString()); // open-world.jpeg (1000 bytes)

const file2 = new CustomFile1(file);
console.log(file2.toString()); // (copy) open-world.jpeg (1000 bytes)

const file3 = new CustomFile1(file2);
console.log(file2.toString()); // (copy) open-world.jpeg (1000 bytes)

// --------->36 tasks ---> Property and Method Protection

// private => only accessible within class
class PointPrivate {
  private x: number;

  private y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

const p = new PointPrivate(10, 8);
//p.x; // Property 'x' is private and only accessible within class 'Point'.
//p.y; // Property 'y' is private and only accessible within class 'Point'.

// protected => only accessible within class and its subclasses
class PointProtected {
  protected x: number;

  protected y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

class Point3D extends PointProtected {
  protected z: number;

  constructor(x: number, y: number, z: number) {
    super(x, y);
    this.z = z;
  }

  public getCoordinates() {
    return [this.x, this.y, this.z]; // OK
  }
}

const pointProtected = new Point3D(10, 8, 5);
//pointProtected.x; // Property 'x' is protected and only accessible within class 'Point' and its subclasses.
//pointProtected.y; // Property 'y' is protected and only accessible within class 'Point' and its subclasses.
//pointProtected.z; // Property 'z' is protected and only accessible within class 'Point3D' and its subclasses.

// exercise

type CustomFileOptions = {
  name: string;
  size: number;
};

class CustomFile2 {
  private name: string;

  private size: number;

  constructor(options: CustomFileOptions) {
    this.name = options.name;
    this.size = options.size;
  }

  protected toString() {
    return `${this.name} (${this.size} bytes)`;
  }
}

class ImageCustomFile extends CustomFile2 {
  private width: number;

  private height: number;

  constructor(options: CustomFileOptions & { width: number; height: number }) {
    super(options);
    this.width = options.width;
    this.height = options.height;
  }

  toString() {
    return `${super.toString()} ${this.width}x${this.height}`;
  }
}

// --------->37 tasks ---> Options Properties

class CustomFile3 {
  constructor(public name: string, private size: number) {}

  toString() {
    return `${this.name} (${this.size} bytes)`;
  }
}

// --------->38 tasks ---> Inheritance

// 1
class CustomFile4 {
  constructor(public name: string, public size: number) {}
}

class ImageCustomFile2 extends CustomFile4 {
  constructor(
    name: string,
    size: number,
    public width: number,
    public height: number
  ) {
    super(name, size);
  }
}

// example
class HttpError extends Error {
  constructor(public status: number, message: string) {
    super(message);
  }
}

class NotFoundError extends HttpError {
  constructor(message: string) {
    super(404, message);
  }
}

class UnauthorizedError extends HttpError {
  constructor(message: string) {
    super(401, message);
  }
}

class ForbiddenError extends HttpError {
  constructor(message: string) {
    super(403, message);
  }
}

// --------->39 tasks ---> Static Methods and Properties

// ÐÐ½Ð¾Ð³Ð´Ð° Ð½Ð°Ð¼ ÑÑÐµÐ±ÑÐµÑÑÑ Ð·Ð°Ð´Ð°ÑÑ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð¾ Ð¸Ð»Ð¸ Ð¼ÐµÑÐ¾Ð´, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð±ÑÐ´ÐµÑ Ð¾Ð±ÑÐ¸Ð¼ Ð´Ð»Ñ Ð²ÑÐµÑ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑÐ¾Ð² ÑÑÐ¾Ð³Ð¾ ÐºÐ»Ð°ÑÑÐ°. ÐÐ°Ð¿ÑÐ¸Ð¼ÐµÑ, ÑÑÐ¾Ð±Ñ Ð¾Ð¿ÑÐµÐ´ÐµÐ»Ð¸ÑÑ, ÑÐ²Ð»ÑÐµÑÑÑ Ð»Ð¸ Ð¾Ð±ÑÐµÐºÑ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑÐ¾Ð¼ ÐºÐ»Ð°ÑÑÐ°. Ð ÑÐ°ÐºÐ¾Ð¼ ÑÐ»ÑÑÐ°Ðµ Ð¿ÑÐ¸ Ð¾Ð±ÑÑÐ²Ð»ÐµÐ½Ð¸Ð¸ Ð¼ÐµÑÐ¾Ð´Ð° Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ ÑÐºÐ°Ð·Ð°ÑÑ ÐºÐ»ÑÑÐµÐ²Ð¾Ðµ ÑÐ»Ð¾Ð²Ð¾ static, Ð¸ Ð¾Ð½ ÑÑÐ°Ð½ÐµÑ Ð´Ð¾ÑÑÑÐ¿ÐµÐ½ ÑÐµÑÐµÐ· Ð¸Ð¼Ñ ÐºÐ»Ð°ÑÑÐ°:

class CustomFile5 {
  private static readonly maxCustomFileSize = 1000;

  static isCustomFile(file: CustomFile5): boolean {
    return file instanceof CustomFile5;
  }

  protected static isCustomFileTooBig(size: number): boolean {
    return size > CustomFile5.maxCustomFileSize;
  }

  constructor(private name: string, private size: number) {
    if (CustomFile5.isCustomFileTooBig(size)) {
      throw new Error('CustomFile is too big');
    }
  }
}

CustomFile5.isCustomFile(new CustomFile5('open-world.jpeg', 1000)); // true

// Ð¡ÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸Ð¼ Ð¼ÐµÑÐ¾Ð´Ð°Ð¼ Ð¸ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð°Ð¼ ÑÐ°ÐºÐ¶Ðµ Ð¼Ð¾Ð¶Ð½Ð¾ Ð½Ð°Ð·Ð½Ð°ÑÐ¸ÑÑ Ð¼Ð¾Ð´Ð¸ÑÐ¸ÐºÐ°ÑÐ¾ÑÑ Ð´Ð¾ÑÑÑÐ¿Ð° public, protected Ð¸ private Ð¸ Ð¼Ð¾Ð´Ð¸ÑÐ¸ÐºÐ°ÑÐ¾Ñ Ð½ÐµÐ¸Ð·Ð¼ÐµÐ½ÑÐµÐ¼Ð¾ÑÑÐ¸ readonly. Ð­ÑÐ¾ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐ¸ÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ²Ð¾Ð¹ÑÑÐ² Ð¸ Ð¼ÐµÑÐ¾Ð´Ð¾Ð² ÑÐ¾Ð»ÑÐºÐ¾ ÑÐµÐºÑÑÐ¸Ð¼ ÐºÐ»Ð°ÑÑÐ¾Ð¼ Ð¸Ð»Ð¸ Ð½Ð°ÑÐ»ÐµÐ´Ð½Ð¸ÐºÐ°Ð¼Ð¸.

// Ð Ð¾ÑÐ»Ð¸ÑÐ¸Ð¸ Ð¾Ñ JavaScript Ð² TypeScript ÑÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸Ðµ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° Ð¸ Ð¼ÐµÑÐ¾Ð´Ñ Ð½Ðµ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ Ð¿ÐµÑÐµÐ¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ñ Ð² Ð¿Ð¾Ð´ÐºÐ»Ð°ÑÑÐ°Ñ:

class CustomFile6 {
  static maxCustomFileSize = 1000;

  static isCustomFile(file: CustomFile6): boolean {
    return file instanceof CustomFile6;
  }
}

class ImageCustomFile1 extends CustomFile6 {
  static maxCustomFileSize = 2000; // Error!

  static isCustomFile(file: CustomFile6): boolean {
    // Error!
    return file instanceof ImageCustomFile1;
  }
}

// Ð¢Ð°ÐºÐ¾Ð¹ ÐºÐ¾Ð´ Ð½Ðµ ÑÐ´Ð°ÑÑÑÑ ÑÐºÐ¾Ð¼Ð¿Ð¸Ð»Ð¸ÑÐ¾Ð²Ð°ÑÑ. ÐÑÐ¸ ÑÑÐ¾Ð¼ Ð¾ÑÑÐ°ÐµÑÑÑ Ð´Ð¾ÑÑÑÐ¿ Ðº ÑÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸Ð¼ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð°Ð¼ Ð¸ Ð¼ÐµÑÐ¾Ð´Ð°Ð¼ ÑÐ¾Ð´Ð¸ÑÐµÐ»ÑÑÐºÐ¾Ð³Ð¾ ÐºÐ»Ð°ÑÑÐ°:

// const file = new ImageCustomFile();
// console.log(ImageCustomFile.maxCustomFileSize); // 1000
// console.log(ImageCustomFile.isCustomFile(file)); // true

// example:

class UserResponse1 {
  constructor(public user: string) {}

  static fromArray(array: string[]): UserResponse1[] {
    return array.map(item => new UserResponse1(item));
  }
}

const response = UserResponse1.fromArray(['user1', 'user2', 'user3']);
console.log(response[0].user); // user1
console.log(response[0] instanceof UserResponse1); // true

// --------->40 tasks ---> Abstract Class

// ÐÐ¾Ð³Ð´Ð° Ð½Ð°Ð¼ Ð½ÑÐ¶Ð½Ð¾ Ð¾Ð¿ÑÐµÐ´ÐµÐ»Ð¸ÑÑ Ð¾Ð±ÑÐµÐµ Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¸Ñ ÐºÐ»Ð°ÑÑÐ¾Ð², ÑÐ´Ð¾Ð±Ð½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ
// ÐÐ±ÑÑÑÐ°ÐºÑÐ½ÑÐµ ÐºÐ»Ð°ÑÑÑ ÑÐ¾ÑÑ Ð¸ Ð½Ðµ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ ÑÐ¾Ð·Ð´Ð°Ð½Ñ Ð½Ð°Ð¿ÑÑÐ¼ÑÑ, Ð¾Ð´Ð½Ð°ÐºÐ¾ Ð¾Ð½Ð¸ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ Ð½Ð°ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ñ. ÐÑÐµ Ð¾Ð½Ð¸ Ð¼Ð¾Ð³ÑÑ ÑÐºÐ°Ð·Ð°ÑÑ ÑÐ²Ð½Ð¾, ÐºÐ°ÐºÐ¾Ð¹ Ð¼ÐµÑÐ¾Ð´ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð±ÑÑÑ ÑÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð½ Ð² Ð½Ð°ÑÐ»ÐµÐ´Ð½Ð¸ÐºÐ°Ñ:

abstract class CustomFile7 {
  protected name: string;

  protected size: number;

  constructor(name: string, size: number) {
    this.name = name;
    this.size = size;
  }

  sizeInKb(): number {
    return this.size / 1024;
  }
}

class ImageCustomFile7 extends CustomFile7 {
  constructor(name: string, size: number) {
    super(name, size);
  }
}

// Ð§ÑÐ¾Ð±Ñ Ð²ÑÐ½Ð¾ÑÐ¸ÑÑ Ð¸Ð· ÐºÐ»Ð°ÑÑÐ¾Ð² Ð¾Ð±ÑÑÑ ÑÐ°ÑÑÑ ÐºÐ¾Ð´Ð°, Ð°Ð±ÑÑÑÐ°ÐºÑÐ½ÑÐµ ÐºÐ»Ð°ÑÑÑ Ð°ÐºÑÐ¸Ð²Ð½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑÑÑÑ Ð´Ð»Ñ Ð¿Ð¾ÑÑÑÐ¾ÐµÐ½Ð¸Ñ Ð°ÑÑÐ¸ÑÐµÐºÑÑÑÑ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð¸ ÑÑÐµÐ¹Ð¼Ð²Ð¾ÑÐºÐ¾Ð². ÐÐ°Ð¿ÑÐ¸Ð¼ÐµÑ, Ð² React ÐµÑÑÑ ÐºÐ»Ð°ÑÑ Component, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÐµÐ½ ÐºÐ°Ðº Ð°Ð±ÑÑÑÐ°ÐºÑÐ½ÑÐ¹ ÐºÐ»Ð°ÑÑ. ÐÑ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÐ¼ ÑÐ¾Ð·Ð´Ð°ÑÑ ÐµÐ³Ð¾ Ð½Ð°Ð¿ÑÑÐ¼ÑÑ, Ð½Ð¾ Ð¾Ð½ ÑÑÐµÐ±ÑÐµÑ Ð¾Ñ Ð½Ð°ÑÐ»ÐµÐ´Ð½Ð¸ÐºÐ¾Ð² ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð¼ÐµÑÐ¾Ð´Ð° render. Ð­ÑÐ¾ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½ÑÑ, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð±ÑÐ´ÑÑ ÑÐµÐ½Ð´ÐµÑÐ¸ÑÑÑÑ Ð¿ÑÐ¸ Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸:

abstract class Component {
  abstract render(): void;

  constructor() {
    this.render();
  }
}

// exercise

abstract class Clock {
  constructor(
    protected hours: number,
    protected minutes: number,
    protected seconds: number
  ) {
    this.hours = hours;
    this.minutes = minutes;
    this.seconds = seconds;
    this.render();
  }

  tick(): void {
    this.seconds += 1;
    if (this.seconds === 60) {
      this.seconds = 0;
      this.minutes += 1;
    }
    if (this.minutes === 60) {
      this.minutes = 0;
      this.hours += 1;
    }
    if (this.hours === 24) {
      this.hours = 0;
      this.minutes = 0;
      this.seconds = 0;
    }
  }

  abstract render(): string;
}

// ---------> 41 tasks ---> About Interfaces

// ÐÐ½ÑÐµÑÑÐµÐ¹Ñ â ÑÑÐ¾ ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ñ ÑÐ·ÑÐºÐ° TypeScript, ÐºÐ¾ÑÐ¾ÑÐ°Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ, ÑÑÐ¾Ð±Ñ Ð¾Ð¿Ð¸ÑÑÐ²Ð°ÑÑ Ð¾Ð±ÑÐµÐºÑÑ Ð¸ ÑÑÐ½ÐºÑÐ¸Ð¸.
// ÐÐ»Ð°Ð²Ð½Ð°Ñ Ð¾ÑÐ¾Ð±ÐµÐ½Ð½Ð¾ÑÑÑ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ¾Ð² ÑÐ²ÑÐ·Ð°Ð½Ð° Ñ ÐºÐ»Ð°ÑÑÐ°Ð¼Ð¸. ÐÐ»Ð°ÑÑÑ, ÐºÐ¾ÑÐ¾ÑÑÐµ ÑÐµÐ°Ð»Ð¸Ð·ÑÑÑ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÑ, ÑÐ¾Ð´ÐµÑÐ¶Ð°Ñ Ð²Ð½ÑÑÑÐ¸ ÑÐµÐ±Ñ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° Ð¸ Ð¼ÐµÑÐ¾Ð´Ñ, ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐµ Ð² ÑÐµÐ°Ð»Ð¸Ð·ÑÐµÐ¼Ð¾Ð¼ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐµ:

interface Countable {
  count(): number;
}

class SchoolClass implements Countable {
  // Ð¢ÑÑ ÐºÐ°ÐºÐ°Ñ-ÑÐ¾ Ð»Ð¾Ð³Ð¸ÐºÐ°
  count(): number {
    // ÐÐ±ÑÐ·Ð°ÑÐµÐ»ÑÐ½Ð¾ ÑÐ¾Ð·Ð´Ð°ÑÑ ÑÑÐ¾Ñ Ð¼ÐµÑÐ¾Ð´, ÑÐ°Ðº ÐºÐ°Ðº Ð¾Ð½ ÑÐºÐ°Ð·Ð°Ð½ Ð² Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐµ
    return 1;
  }
}

const sc = new SchoolClass();
// ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ ÑÐ¸ÑÐ»Ð¾ ÑÑÑÐ´ÐµÐ½ÑÐ¾Ð² Ð² ÐºÐ»Ð°ÑÑÐµ
sc.count();

// Ð ÑÑÐ¾Ð¼ Ð¿ÑÐ¸Ð¼ÐµÑÐµ Ð¼Ñ ÑÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð»Ð¸ ÐºÐ»Ð°ÑÑ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ°. Ð¢ÐµÐ¿ÐµÑÑ Ð²Ð¾ Ð²ÑÐµÑ ÑÑÐ½ÐºÑÐ¸ÑÑ, Ð³Ð´Ðµ Ð¾Ð±ÑÐµÐºÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑÑÑÑ ÑÐ¾Ð»ÑÐºÐ¾ Ð´Ð»Ñ ÑÐ¾Ð³Ð¾, ÑÑÐ¾Ð±Ñ Ð¿Ð¾ÑÑÐ¸ÑÐ°ÑÑ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐµÐ³Ð¾-Ð»Ð¸Ð±Ð¾ Ð²Ð½ÑÑÑÐ¸ Ð½Ð¸Ñ, Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐºÐ°Ð·ÑÐ²Ð°ÑÑ Countable Ð²Ð¼ÐµÑÑÐ¾ SchoolClass:

// Ð Ð½Ðµ function doSomething(obj: SchoolClass)
function doSomething(obj: Countable) {
  // ÐÐ´Ðµ-ÑÐ¾ Ð²Ð½ÑÑÑÐ¸ Ð²ÑÐ·ÑÐ²Ð°ÐµÑÑÑ
  obj.count();
}

// Ð¢Ð°Ðº Ð±Ð»Ð°Ð³Ð¾Ð´Ð°ÑÑ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ°Ð¼ ÑÑÐ½ÐºÑÐ¸Ñ ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑÑ Ð±Ð¾Ð»ÐµÐµ ÑÐ½Ð¸Ð²ÐµÑÑÐ°Ð»ÑÐ½Ð¾Ð¹. ÐÑ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¿ÐµÑÐµÐ´Ð°ÑÑ Ð»ÑÐ±ÑÐµ Ð¾Ð±ÑÐµÐºÑÑ, ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÑÑÐ¸Ðµ Countable, Ð° Ð½Ðµ ÑÐ¾Ð»ÑÐºÐ¾ SchoolClass. Ð Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ð¸ ÑÐ°ÐºÐ°Ñ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑÑ Ð½Ð°Ð·ÑÐ²Ð°ÐµÑÑÑ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾ÑÑÐ¸Ð·Ð¼Ð¾Ð¼ Ð¿Ð¾Ð´ÑÐ¸Ð¿Ð¾Ð² (Subtyping).

// exercise

interface IVehicle {
  seats: number;
  colour: string;
  canHavePassengers: boolean;
  fuelPer100Kilometers: number;
  calcFuelNeeded(distance: number): number;
}

class Car implements IVehicle {
  constructor(
    public seats: number,
    public colour: string,
    public canHavePassengers: boolean,
    public fuelPer100Kilometers: number
  ) {}
  calcFuelNeeded(distance: number): number {
    const fuelPer1Kilometers = this.fuelPer100Kilometers / 100;
    return distance * fuelPer1Kilometers;
  }
}

// ---------> 42 tasks ---> Use of interfaces

// ÐÑÐ»Ð¸ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾ ÑÐ°ÑÑÐ¸ÑÐ¸ÑÑ Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐ¼Ð¸ Ð¿Ð¾Ð»ÑÐ¼Ð¸ Ð¿Ð¾ÑÐ»Ðµ ÐµÐ³Ð¾ Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸, Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¿Ð¾Ð²ÑÐ¾ÑÐ½Ð¾ Ð¾Ð±ÑÑÐ²Ð¸ÑÑ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ Ñ Ð½Ð¾Ð²ÑÐ¼Ð¸ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð°Ð¼Ð¸. Ð¢Ð°ÐºÐ¾Ð¹ ÑÐ¿Ð¾ÑÐ¾Ð± Ð½Ð°Ð·ÑÐ²Ð°ÐµÑÑÑ ÑÐ»Ð¸ÑÐ½Ð¸ÐµÐ¼ Ð´ÐµÐºÐ»Ð°ÑÐ°ÑÐ¸Ð¹:

interface IUser {
  rating: number;
}

interface IUser {
  nickname: string;
  birthdate: number;
}

const sergey: IUser = {
  nickname: 'Sergey',
  birthdate: 1990,
  rating: 1102,
};

// ÐÑ Ð¼Ð¾Ð¶ÐµÐ¼ ÑÐ°ÑÑÐ¸ÑÐ¸ÑÑ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð´ÑÑÐ³Ð¾Ð³Ð¾ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ°, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð½Ð°ÑÐ»ÐµÐ´ÑÐµÑÑÑ Ð¾Ñ Ð½ÐµÐ³Ð¾:

interface IStudent extends IUser {
  group: number;
}

const andrey: IStudent = {
  nickname: 'Andrey',
  birthdate: 1990,
  rating: 1102,
  group: 2,
};

// ÐÑÐµ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÑ Ð¼Ð¾Ð³ÑÑ ÑÐ°ÑÑÐ¸ÑÑÑÑ ÑÑÐ°Ð·Ñ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ Ð´ÑÑÐ³Ð¸Ñ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ¾Ð²:
interface IUser1 {
  nickname: string;
  rating: number;
}

interface IEditor {
  courses: [string];
  canEdit: boolean;
}

interface IAuthor extends IUser1, IEditor {
  team: string;
}

const ivan: IAuthor = {
  nickname: 'Ivan',
  rating: 20,
  courses: ['typescript'],
  canEdit: true,
  team: 'College',
};

// Ð¢Ð°ÐºÐ¶Ðµ TypeScript Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ Ð½Ð°Ð¼ ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ½ÑÐµ ÑÐ¸Ð¿Ñ (intersection types) Ð¸Ð· Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¸Ñ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ¾Ð² c Ð¿Ð¾Ð¼Ð¾ÑÑÑ Ð»Ð¸ÑÐµÑÐ°Ð»Ð° &:

interface IOneWay {
  one: string;
}

interface IOrAnother {
  another: string;
}

type OneWayOrAnother = IOneWay & IOrAnother;

const example: OneWayOrAnother = {
  one: 'A',
  another: 'B',
};

// ÐÐ¾Ð¶ÐµÑ ÑÐ»ÑÑÐ¸ÑÑÑÑ ÑÐ°Ðº, ÑÑÐ¾ Ð¼Ñ Ð½Ðµ Ð·Ð½Ð°ÐµÐ¼ Ð·Ð°ÑÐ°Ð½ÐµÐµ Ð²ÑÐµÑ ÑÐ²Ð¾Ð¹ÑÑÐ², ÐºÐ¾ÑÐ¾ÑÑÐµ Ð±ÑÐ´ÑÑ ÑÐ¾Ð´ÐµÑÐ¶Ð°ÑÑÑÑ Ð² Ð½Ð°ÑÐµÐ¼ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐµ. ÐÐ¾ Ð½Ð°Ð¼ Ð¸Ð·Ð²ÐµÑÑÐ½Ð¾ Ð¸Ñ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾Ðµ ÑÐ¾Ð´ÐµÑÐ¶Ð°Ð½Ð¸Ðµ. Ð ÑÐ°ÐºÐ¾Ð¼ ÑÐ»ÑÑÐ°Ðµ ÑÐ´Ð¾Ð±Ð½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÐ¿ÐµÑÐ¸Ð°Ð»ÑÐ½ÑÑ Ð¸Ð½Ð´ÐµÐºÑÐ½ÑÑ ÑÐ¸Ð³Ð½Ð°ÑÑÑÑ, ÐºÐ¾ÑÐ¾ÑÐ°Ñ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ Ð¾Ð¿Ð¸ÑÐ°ÑÑ ÑÐ¸Ð¿Ñ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½ÑÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹:

interface IPhoneBook {
  [index: string]: number;
}

const myNotePad: IPhoneBook = {
  ivan: 55531311,
  sergey: 55500110,
  mom: 55522111,
};

// training

interface IFlying {
  canFly: true;
}

interface IBird extends IFlying {
  isLiving: true;
}

interface IPlane extends IFlying {
  canCarryPeople: true;
}

interface ISuperMan extends IBird, IPlane {
  guessWho: (value: string) => string;
}

const superMan: ISuperMan = {
  canFly: true,
  isLiving: true,
  canCarryPeople: true,

  guessWho: (value: string) => {
    if (value.toLowerCase() === 'superman') {
      return `It's a ${value}!`;
    } else {
      return `It's a ${value}?`;
    }
  },
};

// ---------> 43 tasks ---> Realization of interfaces by classess

// => ÐÐ½ÑÐµÑÑÐµÐ¹ÑÑ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ ÑÐ°ÑÑÐ¸ÑÐµÐ½Ñ ÐºÐ»Ð°ÑÑÐ°Ð¼Ð¸:
interface IBeep {
  sayBeep: () => string;
}

interface IBoop {
  sayBoop: () => string;
}

class Robo implements IBeep, IBoop {
  sayBeep = () => 'beep';

  sayBoop = () => 'boop';
}

const R2D2 = new Robo();
R2D2.sayBeep(); // 'beep'

// => Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÐºÐ»Ð°ÑÑÐ° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ° Ð½Ðµ Ð²ÐµÐ´ÐµÑ Ðº ÑÐ¾ÑÐ½Ð¾Ð¹ ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸ ÑÑÐ¾Ð³Ð¾ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ° Ð² ÐºÐ»Ð°ÑÑÐµ. TypeScript Ð¿ÑÐ¾ÑÑÐ¾ Ð¿ÑÐ¾Ð²ÐµÑÑÐµÑ, ÑÐ´Ð¾Ð²Ð»ÐµÑÐ²Ð¾ÑÑÑÑ Ð»Ð¸ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° Ð¸ Ð¼ÐµÑÐ¾Ð´Ñ Ð½Ð°ÑÐµÐ³Ð¾ ÐºÐ»Ð°ÑÑÐ° ÑÐ²Ð¾Ð¹ÑÑÐ²Ð°Ð¼, Ð·Ð°ÑÐ²Ð»ÐµÐ½Ð½ÑÐ¼ Ð² Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐµ. Ð¡Ð°Ð¼ Ð¶Ðµ ÐºÐ»Ð°ÑÑ Ð¼Ñ Ð¿Ð¸ÑÐµÐ¼ Ð²ÑÑÑÐ½ÑÑ.

interface ICalculate {
  sum: (num1: number, num2: number) => number;
}

class Summator implements ICalculate {
  sum(num1: number, num2: number) {
    return num1 + num2;
  }

  // ÐÑÐ»Ð¸ Ð¼ÐµÑÐ¾Ð´ Ð±ÑÐ´ÐµÑ Ð·Ð°Ð¿Ð¸ÑÐ°Ð½ ÑÐ°Ðº:
  // sum(num1, num2) {
  //   return num1 + num2;
  // }
  // ÐÐ»Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² Ð±ÑÐ´ÐµÑ Ð²ÑÐ²ÐµÐ´ÐµÐ½Ð¾ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ: Parameter 'num1'/'num2' implicitly has an 'any' type,
  // Ð¿Ð¾ÑÐ¾Ð¼Ñ ÑÑÐ¾ TypeScript ÑÐ¾Ð»ÑÐºÐ¾ Ð¿ÑÐ¾Ð²ÐµÑÑÐµÑ ÐºÐ»Ð°ÑÑ Ð½Ð° ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¸Ðµ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÑ, Ð½Ð¾ Ð½Ðµ Ð½Ð°ÑÐ»ÐµÐ´ÑÐµÑÑÑ Ð¾Ñ Ð½ÐµÐ³Ð¾ Ð¿Ð¾Ð»Ð½Ð¾ÑÐµÐ½Ð½Ð¾

  multiply(num1: number, num2: number) {
    return num1 * num2;
  }
  // ÐÑ Ð´Ð¾Ð±Ð°Ð²Ð¸Ð»Ð¸ Ð½Ð¾Ð²ÑÐ¹ Ð¼ÐµÑÐ¾Ð´, Ð½Ð¾ TypeScript Ð½Ðµ ÑÑÐ³Ð°ÐµÑÑÑ
}

let calculator = new Summator();
// ÐÐ°Ñ ÐºÐ¾Ð´ ÑÑÐ°Ð±Ð¾ÑÐ°ÐµÑ, ÐºÐ°Ðº ÐµÑÐ»Ð¸ Ð±Ñ Ð¾Ð½ ÑÑÐ°Ð±Ð¾ÑÐ°Ð» Ð´Ð»Ñ Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ¾Ð² Ñ ÑÐ¸Ð¿Ð¾Ð¼ any,
// Ð¿Ð¾ÑÐ¾Ð¼Ñ ÑÑÐ¾ ÑÐ¸Ð¿Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð², ÑÐ°Ð²Ð½Ð¾ ÐºÐ°Ðº Ð¸ Ð²ÑÐµ Ð¾ÑÑÐ°Ð»ÑÐ½Ð¾Ðµ, Ð½Ðµ Ð±ÑÐ»Ð¸ ÑÐ½Ð°ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ñ ÐºÐ»Ð°ÑÑÐ¾Ð¼ Ð¿ÑÐ¸ ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ°
calculator.sum(2, 3); // 5

// => ÐÑÐ¸Ð±ÐºÐ° Ð² ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ° ÐºÐ»Ð°ÑÑÐ¾Ð¼ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð° ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ¾Ð³Ð´Ð°, ÐºÐ¾Ð³Ð´Ð° Ð¼Ñ Ð½Ðµ ÑÐµÐ°Ð»Ð¸Ð·ÑÐµÐ¼ Ð¾Ð´Ð½Ð¾ Ð¸Ð· ÑÐ²Ð¾Ð¹ÑÑÐ², ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÑ Ð² Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐµ. ÐÐ»Ð¸ Ð¼Ñ ÑÐµÐ°Ð»Ð¸Ð·ÑÐµÐ¼ ÐµÐ³Ð¾ Ð½Ðµ ÑÐ°Ðº, ÐºÐ°Ðº ÑÐºÐ°Ð·Ð°Ð½Ð¾ Ð² Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐµ:

interface ICalculate1 {
  sum: (num1: number, num2: number) => number;
}

class Summator1 implements ICalculate1 {
  sum(num1: number, num2: number) {
    return num1 + num2;
  }

  // ÐÑÐ»Ð¸ Ð¼ÐµÑÐ¾Ð´ Ð±ÑÐ´ÐµÑ Ð² Ñ ÑÐ°ÐºÐ¸Ð¼Ð¸ ÑÐ¸Ð¿Ð°Ð¼Ð¸ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð²:

  // sum(num1: string, num2: string) {
  //   return num1 + num2;
  // }

  // ÐÑ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»Ð¸ ÑÐ¸Ð¿Ñ Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ¾Ð² Ð½Ð° string, ÑÐ¾ ÐµÑÑÑ Ð½ÐµÐ²ÐµÑÐ½Ð¾ ÑÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð»Ð¸ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ
  // Ð ÑÐ°ÐºÐ¾Ð¼ ÑÐ»ÑÑÐ°Ðµ TypeScript Ð¾Ð±ÑÐ°ÑÐ¸Ñ Ð²Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµ Ð½Ð° Ð½Ð°ÑÑ Ð¾ÑÐ¸Ð±ÐºÑ Ð¸ Ð½Ðµ ÑÐºÐ¾Ð¼Ð¿Ð¸Ð»Ð¸ÑÑÐµÑÑÑ:
  // Type '(num1: string, num2: string) => string' is not assignable to type '(num1: number, num2: number) => number'.
}

// => ÐÑÐ»Ð¸ Ð¼Ñ Ð¿Ð¸ÑÐµÐ¼ ÐºÐ»Ð°ÑÑ, ÑÐµÐ°Ð»Ð¸Ð·ÑÑÑÐ¸Ð¹ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ Ñ Ð¾Ð¿ÑÐ¸Ð¾Ð½Ð°Ð»ÑÐ½ÑÐ¼Ð¸ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð°Ð¼Ð¸, Ð½Ð°Ð¼ Ð½ÑÐ¶Ð½Ð¾ Ð¿ÑÐ¾Ð¿Ð¸ÑÑÐ²Ð°ÑÑ Ð²ÑÐµ ÑÐ°Ð¼Ð¾ÑÑÐ¾ÑÑÐµÐ»ÑÐ½Ð¾. Ð Ð¿ÑÐ¾ÑÐ¸Ð²Ð½Ð¾Ð¼ ÑÐ»ÑÑÐ°Ðµ ÑÑÐ¸ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° Ð½Ðµ Ð¿Ð¾Ð¿Ð°Ð´ÑÑ Ð² Ð½Ð°Ñ ÐºÐ»Ð°ÑÑ:

interface ICalculate2 {
  sum: (num1: number, num2: number) => number;
  multiply?: (num1: number, num2: number) => number;
}

class Summator2 implements ICalculate2 {
  sum(num1: number, num2: number) {
    return num1 + num2;
  }
}

const calculator2 = new Summator2();
calculator2.sum(2, 3); // 5
// calculator2.multiply(2, 3); // Property 'multiply' does not exist on type 'Summator'.

// ÐÑÐ²Ð¾Ð´Ñ:
// ÐÐ¾ÑÐºÐ¾Ð»ÑÐºÑ Ð² TypeScript Ð´Ð»Ñ Ð¾Ð´Ð½Ð¸Ñ Ð¸ ÑÐµÑ Ð¶Ðµ Ð²ÐµÑÐµÐ¹ ÑÑÑÐµÑÑÐ²ÑÐµÑ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÐ°Ð·Ð½ÑÑ Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½ÑÐ¾Ð², Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ ÑÐµÐ°Ð»Ð¸Ð·Ð¾Ð²ÑÐ²Ð°ÑÑ ÐºÐ»Ð°ÑÑÑ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ ÑÐ°ÑÑÐ¸ÑÐµÐ½Ð¸Ñ Ð°Ð±ÑÑÑÐ°ÐºÑÐ½ÑÑ ÐºÐ»Ð°ÑÑÐ¾Ð² Ð²Ð¼ÐµÑÑÐ¾ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ¾Ð². ÐÐ¾ Ð²ÑÐ±Ð¾Ñ Ð±ÑÐ´ÐµÑ Ð·Ð°Ð²Ð¸ÑÐµÑÑ Ð¾Ñ Ð·Ð°Ð´Ð°ÑÐ¸. ÐÐ±ÑÑÑÐ°ÐºÑÐ½ÑÐµ ÐºÐ»Ð°ÑÑÑ Ð¿ÑÐµÐ´Ð¾ÑÑÐ°Ð²Ð»ÑÑÑ Ð½Ð°Ð¼ Ð¼Ð¾Ð´Ð¸ÑÐ¸ÐºÐ°ÑÐ¾ÑÑ Ð´Ð¾ÑÑÑÐ¿Ð° Ð¸ ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¾ÑÑ, Ð² ÑÐ¾ Ð²ÑÐµÐ¼Ñ ÐºÐ°Ðº Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÑ Ð±Ð¾Ð»ÐµÐµ Ð»ÐµÐ³ÐºÐ¾Ð²ÐµÑÐ½Ñ Ð¸ Ð¿ÑÐ¾ÑÑÑ.

//ÐÐ°Ð´Ð°Ð½Ð¸Ðµ:
// Ð¡ Ð¿Ð¾Ð¼Ð¾ÑÑÑ Ð¿ÑÐµÐ´Ð¾ÑÑÐ°Ð²Ð»ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ° IPhonebook Ð¸ ÑÐ¸Ð¿Ð° Entry ÑÐµÐ°Ð»Ð¸Ð·ÑÐ¹ÑÐµ ÐºÐ»Ð°ÑÑ Phonebook, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÑÐµÑ ÑÐµÐ»ÐµÑÐ¾Ð½Ð½ÑÐ¹ ÑÐ¿ÑÐ°Ð²Ð¾ÑÐ½Ð¸Ðº ÑÐ¾ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼Ð¸ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð°Ð¼Ð¸:

// entries â Ð±Ð°Ð·Ð° Ð´Ð°Ð½Ð½ÑÑ, Ð¾Ð±ÑÐµÐºÑ, Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð² ÐºÐ¾ÑÐ¾ÑÐ¾Ð¼ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÑÑÑ ÑÐ¾Ð±Ð¾Ð¹ Ð¸Ð¼ÐµÐ½Ð° Ð² ÐºÐ°ÑÐµÑÑÐ²Ðµ ÐºÐ»ÑÑÐµÐ¹ Ð¸ ÑÐµÐ»ÐµÑÐ¾Ð½Ñ Ð² ÐºÐ°ÑÐµÑÑÐ²Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹. Ð¡Ð²Ð¾Ð¹ÑÑÐ²Ð¾ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ Ð½ÐµÐ¸Ð·Ð¼ÐµÐ½ÑÐµÐ¼ÑÐ¼ Ð¸ Ð´Ð¾ÑÑÑÐ¿Ð½ÑÐ¼ ÑÐ¾Ð»ÑÐºÐ¾ Ð´Ð»Ñ ÑÑÐµÐ½Ð¸Ñ
// get â Ð¼ÐµÑÐ¾Ð´, Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÑÑÐ¸Ð¹ ÑÐµÐ»ÐµÑÐ¾Ð½ Ð¿Ð¾ Ð¸Ð¼ÐµÐ½Ð¸
// set â Ð¼ÐµÑÐ¾Ð´, Ð·Ð°Ð¿Ð¸ÑÑÐ²Ð°ÑÑÐ¸Ð¹ Ð¸Ð¼Ñ Ð¸ ÑÐµÐ»ÐµÑÐ¾Ð½ Ð² ÑÐ¿ÑÐ°Ð²Ð¾ÑÐ½Ð¸Ðº
// ÐÑÐ¸Ð¼ÐµÑÑ:
// typescript
// const myNote = new Phonebook();
// myNote.set('help', 911);
// myNote.get('help'); // 911

type Entry = {
  [key: string]: number;
};

interface IPhonebook {
  get(key: string): number | null;
  set(key: string, value: number): void;
}

class Phonebook implements IPhonebook {
  private readonly entries: Entry = {};

  get(key: string): number | null {
    return this.entries[key] || null;
  }

  set(key: string, value: number): void {
    this.entries[key] = value;
  }
}

// ---------> 44 tasks ---> Introduction to generics

// ÐÐ¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸ Ð² Ð¿ÑÐ¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¸ Ðº ÑÑÐ½ÐºÑÐ¸ÑÐ¼ â ÑÑÐ¾ Ð¼ÐµÑÐ°Ð½Ð¸Ð·Ð¼, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑÐ¸Ð¹ ÑÐ¾Ð·Ð´Ð°ÑÑ ÑÐ°ÐºÐ¸Ðµ ÑÑÐ½ÐºÑÐ¸Ð¸, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð¸Ð¼ÐµÑÑ Ð¾Ð´Ð¸Ð½Ð°ÐºÐ¾Ð²ÑÑ Ð»Ð¾Ð³Ð¸ÐºÑ Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐ¸ Ð´Ð»Ñ ÑÐ°Ð·Ð½ÑÑ ÑÐ¸Ð¿Ð¾Ð² Ð´Ð°Ð½Ð½ÑÑ. ÐÐ½Ð¾Ð³Ð´Ð° ÑÐ°ÐºÐ¸Ðµ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð½Ð°Ð·ÑÐ²Ð°ÑÑ Ð¾Ð±Ð¾Ð±ÑÐµÐ½Ð½ÑÐ¼Ð¸ ÑÑÐ½ÐºÑÐ¸ÑÐ¼Ð¸.

// Ð¸Ð»Ð¸ ÑÐ°Ðº
// function merge<T>(coll1: T[], coll2: T[]): T[]
function merge<T>(coll1: Array<T>, coll2: Array<T>): Array<T> {
  // Ð¢ÐµÐ»Ð¾ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð½Ðµ Ð¿Ð¾Ð¼ÐµÐ½ÑÐ»Ð¾ÑÑ!
  const result = [];
  result.push(...coll1);
  result.push(...coll2);
  return result;
}

// Ð Ð°Ð±Ð¾ÑÐ°ÐµÑ Ñ Ð¼Ð°ÑÑÐ¸Ð²Ð°Ð¼Ð¸ Ð»ÑÐ±ÑÑ ÑÐ¸Ð¿Ð¾Ð²
// Ð¡Ð°Ð¼Ð¸ Ð¼Ð°ÑÑÐ¸Ð²Ñ Ð´Ð¾Ð»Ð¶Ð½Ñ Ð¸Ð¼ÐµÑÑ ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÑÑÐ¸Ð¹ ÑÐ¸Ð¿
merge([1, 2], [3, 4]); // [1, 2, 3, 4]
merge(['one', 'two'], ['three']); // ['one', 'two', 'three']

// ÐÐ°Ð¿Ð¸ÑÑ Ð² <T> Ð¿Ð¾ÑÐ»Ðµ Ð¸Ð¼ÐµÐ½Ð¸ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð³Ð¾Ð²Ð¾ÑÐ¸Ñ Ð¾ ÑÐ¾Ð¼, ÑÑÐ¾ Ð¿ÐµÑÐµÐ´ Ð½Ð°Ð¼Ð¸ Ð´Ð¶ÐµÐ½ÐµÑÐ¸Ðº, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸Ð·ÑÐµÑÑÑ ÑÐ¸Ð¿Ð¾Ð¼ T. T â ÑÑÐ¾ Ð¾Ð±Ð¾Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ, ÑÑÐ¾ Ð¼Ñ Ð¼Ð¾Ð³Ð»Ð¸ Ð±Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð»ÑÐ±ÑÑ Ð´ÑÑÐ³ÑÑ Ð·Ð°Ð³Ð»Ð°Ð²Ð½ÑÑ Ð±ÑÐºÐ²Ñ, Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ, X.

// Ð§Ð°ÑÐµ Ð²ÑÐµÐ³Ð¾ Ð¼Ñ Ð±ÑÐ´ÐµÐ¼ Ð²Ð¸Ð´ÐµÑÑ ÑÑÐ¾ Ð¾Ð±Ð¾Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ, ÑÐ°Ðº ÐºÐ°Ðº ÑÑÐ¾ Ð¾Ð±ÑÐµÐ¿ÑÐ¸Ð½ÑÑÐ°Ñ Ð¿ÑÐ°ÐºÑÐ¸ÐºÐ°.

// Ð§ÑÐ¾ ÐºÐ¾Ð½ÐºÑÐµÑÐ½Ð¾ ÑÐºÑÑÐ²Ð°ÐµÑÑÑ Ð¿Ð¾Ð´ ÑÐ¸Ð¿Ð¾Ð¼ Ñ ÑÐ¾ÑÐºÐ¸ Ð·ÑÐµÐ½Ð¸Ñ ÐºÐ¾Ð´Ð° Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ° â Ð½Ðµ Ð²Ð°Ð¶Ð½Ð¾. Ð­ÑÐ¾ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð¾Ð±ÑÐµÐºÑ, ÑÐ¸ÑÐ»Ð¾, ÑÑÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ Ð±ÑÐ»ÐµÐ²Ð¾ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ. Ð Ð²ÑÐ·Ð¾Ð²Ð°Ñ Ð¿ÑÐ¸Ð¼ÐµÑÐ° Ð²ÑÑÐµ ÑÑÐ¾ ÑÐ¸ÑÐ»Ð¾ Ð´Ð»Ñ Ð¿ÐµÑÐ²Ð¾Ð³Ð¾ Ð²ÑÐ·Ð¾Ð²Ð° Ð¸ ÑÑÑÐ¾ÐºÐ° Ð´Ð»Ñ Ð²ÑÐ¾ÑÐ¾Ð³Ð¾. Ð¢Ð°Ðº Ð¶Ðµ Ð¼Ð¾Ð¶Ð½Ð¾ Ð±ÑÐ»Ð¾ Ð±Ñ ÑÐ´ÐµÐ»Ð°ÑÑ Ð²ÑÐ·Ð¾Ð² Ñ Ð±ÑÐ»ÐµÐ²ÑÐ¼Ð¸ Ð·Ð½Ð°ÑÐµÐ½Ð¸ÑÐ¼Ð¸:

merge([true], [false, false]); // [true, false, false]

// ÐÐ¾ ÑÐ¸Ð¿Ñ Ð¼Ð¾Ð³ÑÑ Ð¸ Ð½Ðµ ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÑÑ. ÐÐ¸Ð¶Ðµ Ð¿ÑÐ¸Ð¼ÐµÑ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ°, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ Ð¿ÐµÑÐ²ÑÐ¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ Ð»ÑÐ±Ð¾Ð³Ð¾ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸ null ÐµÑÐ»Ð¸ Ð¾Ð½ Ð¿ÑÑÑÐ¾Ð¹:

function first<T>(coll: Array<T>): T | null {
  return coll.length > 0 ? coll[0] : null;
}

first([]); // null
first([3, 2]); // 3
first(['code-basics', 'hexlet']); // code-basics

// ÐÐ°Ð´Ð°Ð½Ð¸Ðµ
// Ð ÐµÐ°Ð»Ð¸Ð·ÑÐ¹ÑÐµ Ð´Ð¶ÐµÐ½ÐµÑÐ¸Ðº last(), ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¸Ð·Ð²Ð»ÐµÐºÐ°ÐµÑ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ Ð¸Ð· Ð¼Ð°ÑÑÐ¸Ð²Ð° ÐµÑÐ»Ð¸ Ð¾Ð½ ÐµÑÑÑ Ð¸Ð»Ð¸ null â ÐµÑÐ»Ð¸ ÐµÐ³Ð¾ Ð½ÐµÑ:

function lastItem<T>(arr: Array<T>): T | null {
  return arr.length > 0 ? arr[arr.length - 1] : null;
}

lastItem([]); // null
lastItem([3, 2]); // 2
lastItem(['code-basics', 'hexlet']); // hexlet

// ---------> 45 tasks ---> Generic Types

const numbers: Array<number> = [];
numbers.push(1);

const strings: Array<string> = [];
strings.push('hexlet');

// Ð¢Ð¸Ð¿, ÐºÐ¾ÑÐ¾ÑÑÐ¹ ÑÐºÐ°Ð·ÑÐ²Ð°ÐµÑÑÑ Ð²Ð½ÑÑÑÐ¸ ÑÐ³Ð»Ð¾Ð²ÑÑ ÑÐºÐ¾Ð±Ð¾Ðº, Ð½Ð°Ð·ÑÐ²Ð°ÐµÑÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð¼ ÑÐ¸Ð¿Ð°. Ð¢Ð°ÐºÐ¾Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð²ÑÐ±ÑÐ°Ð½Ð¾ Ð½ÐµÑÐ»ÑÑÐ°Ð¹Ð½Ð¾ â ÑÐºÐ°Ð·Ð°Ð½Ð¸Ðµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ° Ð²ÑÐ³Ð»ÑÐ´Ð¸Ñ ÐºÐ°Ðº Ð²ÑÐ·Ð¾Ð² ÑÑÐ½ÐºÑÐ¸Ð¸.

// ÐÑÐµÐ´ÑÑÐ°Ð²Ð¸Ð¼, ÑÑÐ¾ Ð¼Ñ ÑÐ¾ÑÐ¸Ð¼ Ð¾Ð¿ÑÐµÐ´ÐµÐ»Ð¸ÑÑ ÑÐ²Ð¾Ñ ÐºÐ¾Ð»Ð»ÐµÐºÑÐ¸Ñ, ÐºÐ¾ÑÐ¾ÑÐ°Ñ ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ ÐºÐ°Ðº Ð¼Ð°ÑÑÐ¸Ð², Ð½Ð¾ Ñ Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐ¼Ð¸ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑÑÐ¼Ð¸. Ð¢Ð°ÐºÐ¸Ðµ ÐºÐ¾Ð»Ð»ÐµÐºÑÐ¸Ð¸ ÑÐ°ÑÑÐ¾ Ð´ÐµÐ»Ð°ÑÑ Ð² ORM Ð´Ð»Ñ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð´Ð°Ð½Ð½ÑÐ¼Ð¸, Ð·Ð°Ð³ÑÑÐ¶ÐµÐ½Ð½ÑÐ¼Ð¸ Ð¸Ð· Ð±Ð°Ð·Ñ. ÐÐ¿Ð¸ÑÐµÐ¼ ÑÐ½Ð°ÑÐ°Ð»Ð° ÐºÐ¾Ð½ÐºÑÐµÑÐ½ÑÑ Ð²ÐµÑÑÐ¸Ñ ÑÑÐ¾Ð³Ð¾ ÑÐ¸Ð¿Ð°, ÑÐ°Ð±Ð¾ÑÐ°ÑÑÑÑ ÑÐ¾Ð»ÑÐºÐ¾ Ñ ÑÐ¸ÑÐ»Ð°Ð¼Ð¸ Ð¸ Ð¿Ð°ÑÐ¾Ð¹ ÑÑÐ°Ð½Ð´Ð°ÑÑÐ½ÑÑ Ð¼ÐµÑÐ¾Ð´Ð¾Ð²:

type MyColl = {
  data: Array<number>;
  forEach(
    callback: (value: number, index: number, array: Array<number>) => void
  ): void;
  at(index: number): number | undefined;
};

// ÐÐ´ÐµÑÑ Ð¼Ñ Ð²Ð¸Ð´Ð¸Ð¼, ÑÑÐ¾ Ð´Ð°Ð½Ð½ÑÐµ ÐºÐ¾Ð»Ð»ÐµÐºÑÐ¸Ð¸ ÑÑÐ°Ð½ÑÑÑÑ Ð² ÑÐ¸ÑÐ»Ð¾Ð²Ð¾Ð¼ Ð¼Ð°ÑÑÐ¸Ð²Ðµ. ÐÑÐ¸ ÑÑÐ¾Ð¼ Ð² ÑÐ¸Ð¿Ðµ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¾ Ð´Ð²Ð° Ð¼ÐµÑÐ¾Ð´Ð°, Ð¾Ð´Ð¸Ð½ Ð¸Ð· ÐºÐ¾ÑÐ¾ÑÑÑ (forEach) Ð¿ÐµÑÐµÐ´Ð°ÐµÑ ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ ÐºÐ¾Ð»Ð»ÐµÐºÑÐ¸Ð¸ Ð² ÐºÐ¾Ð»Ð±ÐµÐº, Ð° Ð´ÑÑÐ³Ð¾Ð¹ (at) Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ ÐºÐ¾Ð»Ð»ÐµÐºÑÐ¸Ð¸ Ð¿Ð¾ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¸Ð½Ð´ÐµÐºÑÑ. ÐÐ´Ð½Ð° Ð¸Ð· Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½ÑÑ ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¹ ÑÑÐ¾Ð³Ð¾ ÑÐ¸Ð¿Ð° Ð¼Ð¾Ð¶ÐµÑ Ð²ÑÐ³Ð»ÑÐ´ÐµÑÑ ÑÐ°Ðº:

// Ð¢Ð¸Ð¿Ñ Ð¼Ð¾Ð¶Ð½Ð¾ Ð½Ðµ Ð¿ÑÐ¾Ð¿Ð¸ÑÑÐ²Ð°ÑÑ, ÑÐ°Ðº ÐºÐ°Ðº Ð¾Ð½Ð¸ ÑÐºÐ°Ð·Ð°Ð½Ñ Ð² `MyColl`
const coll2: MyColl = {
  data: [1, 3, 8],
  forEach(callback) {
    this.data.forEach(callback);
  },
  at(index) {
    // return this.data.at(index); // target >= ES2022
    return this.data[index];
  },
};

coll2.at(1); // 3

// Ð¢ÐµÐ¿ÐµÑÑ Ð¿Ð¾Ð¿ÑÐ¾Ð±ÑÐµÐ¼ Ð¾Ð±Ð¾Ð±ÑÐ¸ÑÑ ÑÑÐ¾Ñ ÑÐ¸Ð¿, ÑÐ¾ ÐµÑÑÑ ÑÐ´ÐµÐ»Ð°ÑÑ Ð¸Ð· Ð½ÐµÐ³Ð¾ Ð´Ð¶ÐµÐ½ÐµÑÐ¸Ðº. ÐÐ»Ñ ÑÑÐ¾Ð³Ð¾ Ð½ÑÐ¶Ð½Ð¾ ÑÐ´ÐµÐ»Ð°ÑÑ Ð¾Ð´Ð½Ñ Ð¿ÑÐ¾ÑÑÑÑ Ð²ÐµÑÑ: Ð´Ð»Ñ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ¾Ð² ÐºÐ¾Ð»Ð»ÐµÐºÑÐ¸Ð¸ Ð²Ð¼ÐµÑÑÐ¾ number Ð½Ð°Ð¿Ð¸ÑÐ°ÑÑ T (Ð¸Ð»Ð¸ Ð»ÑÐ±Ð¾Ðµ Ð´ÑÑÐ³Ð¾Ðµ Ð¸Ð¼Ñ, Ð½Ð°ÑÐ¸Ð½Ð°ÑÑÐµÐµÑÑ Ñ Ð±Ð¾Ð»ÑÑÐ¾Ð¹ Ð±ÑÐºÐ²Ñ) Ð¸ Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ T ÐºÐ°Ðº Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ ÑÐ¸Ð¿Ð° Ðº Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ:

type MyColl1<T> = {
  data: Array<T>;
  forEach(callback: (value: T, index: number, array: Array<T>) => void): void;
  at(index: number): T | undefined;
};

// ÐÐ° ÑÐ°ÐºÐ¾Ðµ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÑÐ¸Ð¿Ð° Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¼Ð¾ÑÑÐµÑÑ ÐºÐ°Ðº Ð½Ð° ÑÐ²Ð¾ÐµÐ¾Ð±ÑÐ°Ð·Ð½Ð¾Ðµ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÑÑÐ½ÐºÑÐ¸Ð¸. ÐÐ¾Ð³Ð´Ð° ÑÐºÐ°Ð·ÑÐ²Ð°ÐµÑÑÑ ÐºÐ¾Ð½ÐºÑÐµÑÐ½ÑÐ¹ ÑÐ¸Ð¿, Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ ÑÐ°Ðº: MyColl<string>, ÑÐ¾ T Ð² Ð´Ð°Ð½Ð½Ð¾Ð¹ ÑÐ¸ÑÑÐ°ÑÐ¸Ð¸ Ð·Ð°Ð¼ÐµÐ½ÑÐµÑÑÑ Ð½Ð° string Ð²Ð½ÑÑÑÐ¸ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ ÑÐ¸Ð¿Ð°. ÐÑÐ¸ÑÐµÐ¼ ÐµÑÐ»Ð¸ Ð²Ð½ÑÑÑÐ¸ ÑÐ¸Ð¿Ð° Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑÑÑÑ Ð´ÑÑÐ³Ð¸Ðµ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸, ÑÐ¾ Ð¾Ð½Ð¸ "Ð²ÑÐ·ÑÐ²Ð°ÑÑ" ÑÐ¸Ð¿ Ð´Ð°Ð»ÑÑÐµ. Ð¢Ð¾ ÐµÑÑÑ Ð²ÑÐµ ÑÑÐ¾ ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ ÐºÐ°Ðº Ð²Ð»Ð¾Ð¶ÐµÐ½Ð½ÑÐµ Ð²ÑÐ·Ð¾Ð²Ñ ÑÑÐ½ÐºÑÐ¸Ð¹.

// => ÐÐ³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ñ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¾Ð²
// ÐÐ¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸ Ð¼Ð¾Ð³ÑÑ Ð¸Ð¼ÐµÑÑ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ñ. ÐÐ°Ð¿ÑÐ¸Ð¼ÐµÑ, Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ ÑÐºÐ°Ð·Ð°ÑÑ, ÑÑÐ¾ ÑÐ¸Ð¿, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¿ÐµÑÐµÐ´Ð°ÐµÑÑÑ Ð² Ð´Ð¶ÐµÐ½ÐµÑÐ¸Ðº, Ð´Ð¾Ð»Ð¶ÐµÐ½ ÑÐµÐ°Ð»Ð¸Ð·Ð¾Ð²ÑÐ²Ð°ÑÑ ÐºÐ°ÐºÐ¾Ð¹-ÑÐ¾ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ. ÐÐ»Ñ ÑÑÐ¾Ð³Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ ÐºÐ»ÑÑÐµÐ²Ð¾Ðµ ÑÐ»Ð¾Ð²Ð¾ extends. ÐÐ¾Ð¿ÑÑÑÐ¸Ð¼, Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ ÑÐ´ÐµÐ»Ð°ÑÑ ÑÐ°Ðº, ÑÑÐ¾Ð±Ñ Ð½Ð°Ñ ÑÐ¸Ð¿ MyColl ÑÐ°Ð±Ð¾ÑÐ°Ð» ÑÐ¾Ð»ÑÐºÐ¾ Ñ ÑÐ¸Ð¿Ð°Ð¼Ð¸, ÐºÐ¾ÑÐ¾ÑÑÐµ ÑÐµÐ°Ð»Ð¸Ð·ÑÑÑ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ HasId:

interface HasId {
  id: number;
}

type MyColl2<T extends HasId | number> = {
  data: Array<T>;
  forEach(callback: (value: T, index: number, array: Array<T>) => void): void;
  at(index: number): T | undefined;
};

// Ð­ÑÐ¾ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ Ð½Ð°Ð¼ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÐ¸Ð¿ MyColl ÑÐ¾Ð»ÑÐºÐ¾ Ñ ÑÐ¸Ð¿Ð°Ð¼Ð¸, ÐºÐ¾ÑÐ¾ÑÑÐµ ÑÐµÐ°Ð»Ð¸Ð·ÑÑÑ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ HasId. ÐÐ°Ð¿ÑÐ¸Ð¼ÐµÑ, ÑÐ°ÐºÐ¾Ð¹ ÐºÐ¾Ð´ Ð½Ðµ Ð±ÑÐ´ÐµÑ ÑÐ°Ð±Ð¾ÑÐ°ÑÑ:

const coll3: MyColl2<number> = {
  data: [1, 3, 8],
  forEach(callback) {
    this.data.forEach(callback);
  },
  at(index) {
    // return this.data.at(index); // target >= ES2022
    return this.data[index];
  },
};

// Ð¡Ð°Ð¼Ð¸ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸ Ð²ÑÑÑÐµÑÐ°ÑÑÑÑ Ð¿Ð¾Ð²ÑÐµÐ¼ÐµÑÑÐ½Ð¾ Ð² ÐºÐ¾Ð´Ðµ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐº Ð¸ ÑÑÐµÐ¹Ð¼Ð²Ð¾ÑÐºÐ¾Ð². ÐÐ°Ð¿ÑÐ¸Ð¼ÐµÑ Ð² React ÑÐ¸Ð¿Ñ ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½ÑÐ¾Ð² Ð¾Ð±Ð¾ÑÐ°ÑÐ¸Ð²Ð°ÑÑÑÑ Ð² Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸, ÑÑÐ¾Ð±Ñ Ð¼Ð¾Ð¶Ð½Ð¾ Ð±ÑÐ»Ð¾ ÑÐºÐ°Ð·Ð°ÑÑ ÑÐ¸Ð¿Ñ Ð¿ÑÐ¾Ð¿ÑÐ¾Ð². Ð¡ Ð¿Ð¾Ð¼Ð¾ÑÑÑ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¾Ð² Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ Ð±Ð¾Ð»ÐµÐµ ÑÐ½Ð¸Ð²ÐµÑÑÐ°Ð»ÑÐ½ÑÐµ ÑÐ¸Ð¿Ñ, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð¼Ð¾Ð³ÑÑ ÑÐ°Ð±Ð¾ÑÐ°ÑÑ Ñ ÑÐ°Ð·Ð½ÑÐ¼Ð¸ ÑÐ¸Ð¿Ð°Ð¼Ð¸ Ð´Ð°Ð½Ð½ÑÑ

// ÐÐ°Ð´Ð°Ð½Ð¸Ðµ
// Ð ÐµÐ°Ð»Ð¸Ð·ÑÐ¹ÑÐµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¾Ð±Ð¾Ð±ÑÐµÐ½Ð½Ð¾Ð³Ð¾ ÑÐ¸Ð¿Ð° MySet, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÑÐµÑ Ð¸Ð· ÑÐµÐ±Ñ Ð°Ð½Ð°Ð»Ð¾Ð³ Ð¼Ð½Ð¾Ð¶ÐµÑÑÐ²Ð° Set Ð¸Ð· JavaScript.
// Ð¢Ð¸Ð¿ Ð²ÐºÐ»ÑÑÐ°ÐµÑ Ð² ÑÐµÐ±Ñ Ð´Ð²Ð° Ð¼ÐµÑÐ¾Ð´Ð°: add() Ð¸ has(). ÐÐ°Ð½Ð½ÑÐµ Ð²Ð½ÑÑÑÐ¸ Ð´Ð¾Ð»Ð¶Ð½Ñ ÑÑÐ°Ð½Ð¸ÑÑÑÑ Ð² ÑÐ²Ð¾Ð¹ÑÑÐ²Ðµ items

type MySet<T> = {
  data: Array<T>;
  add(item: T): number;
  has(item: T): boolean;
};

const s: MySet<number> = {
  data: [],

  add(item) {
    const dataHaveThisItem = this.data.indexOf(item);
    if (dataHaveThisItem < 0) {
      this.data.push(item);
      return this.data.length;
    } else {
      return this.data.length;
    }
  },

  has(item) {
    const dataHaveThisItem = this.data.indexOf(item);
    if (dataHaveThisItem < 0) {
      return false;
    } else {
      return true;
    }
  },
};

// ---------> 46 tasks ---> Generics (Functions)

// ÐÑÐµÐ´ÑÑÐ°Ð²Ð¸Ð¼, ÑÑÐ¾ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸ Ð¿ÑÐ¾Ð¿Ð°Ð»Ð¸ Ð¸Ð· ÑÐ·ÑÐºÐ°. Ð¢Ð¾Ð³Ð´Ð° Ð¿ÑÐ¾Ð¸Ð·Ð¾Ð¹Ð´ÐµÑ Ð´ÑÐ±Ð»Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð´Ð°. ÐÑÐ¸Ð´ÐµÑÑÑ Ð¾Ð¿Ð¸ÑÑÐ²Ð°ÑÑ Ð¾Ð´Ð¸Ð½ Ð¸ ÑÐ¾Ñ Ð¶Ðµ Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼ Ð´Ð»Ñ ÑÐ°Ð·Ð½ÑÑ ÑÐ¸Ð¿Ð¾Ð² Ð´Ð°Ð½Ð½ÑÑ Ð¼Ð½Ð¾Ð³Ð¾ ÑÐ°Ð·.
// ÐÐ¾Ð·ÑÐ¼ÐµÐ¼ Ð´Ð»Ñ Ð¿ÑÐ¸Ð¼ÐµÑÐ° ÑÑÐ½ÐºÑÐ¸Ñ lastData(), Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÑÑÑÑ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ Ð¼Ð°ÑÑÐ¸Ð²Ð°. ÐÐ¸Ð¶Ðµ ÐµÐµ Ð¾Ð±Ð¾Ð±ÑÐµÐ½Ð½Ð°Ñ Ð²ÐµÑÑÐ¸Ñ:

function lastData<T>(coll: T[]): T {
  return coll[coll.length - 1];
}

// ÐÐ¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸ ÑÐ°ÐºÐ¶Ðµ Ð¼Ð¾Ð³ÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑÑÑ Ð² ÑÑÑÐµÐ»Ð¾ÑÐ½ÑÑ ÑÑÐ½ÐºÑÐ¸ÑÑ:

const lastData1 = <T>(coll: T[]): T => {
  return coll[coll.length - 1];
};

// Ð¢ÐµÐ¿ÐµÑÑ Ð¿Ð¾Ð¿ÑÐ¾Ð±ÑÐµÐ¼ ÑÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°ÑÑ ÑÐ¾ Ð¶Ðµ Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ, Ð½Ð¾ Ð±ÐµÐ· Ð¿ÑÐ¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¾Ð². ÐÐ»Ñ ÑÑÐ¾Ð³Ð¾ Ð½Ð°Ð¼ Ð¿ÑÐ¸Ð´ÐµÑÑÑ ÑÐ¾Ð·Ð´Ð°ÑÑ Ð¿Ð¾ Ð¾Ð´Ð½Ð¾Ð¹ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ ÑÐ¸Ð¿Ð°. ÐÑÐ¸ÑÐµÐ¼ Ð¸Ð¼Ñ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ÑÐ½Ð¸ÐºÐ°Ð»ÑÐ½ÑÐ¼:

function lastForNumberType(coll: number[]): number {
  return coll[coll.length - 1];
}

function lastForStringType(coll: string[]): string {
  return coll[coll.length - 1];
}

// Ð¢ÑÑ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð´Ð»Ñ Ð²ÑÐµÑ Ð¾ÑÑÐ°Ð»ÑÐ½ÑÑ ÑÐ¸Ð¿Ð¾Ð²

// ÐÑÐ»Ð¸ ÑÐ¸Ð¿Ð¾Ð² Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾, ÑÐ¾ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÑÐ½ÐºÑÐ¸Ð¹, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð½ÑÐ¶Ð½Ð¾ Ð¾Ð¿ÑÐµÐ´ÐµÐ»Ð¸ÑÑ, Ð±ÑÐ´ÐµÑ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÑÑÑÑÑ ÐºÐ°Ðº Ð¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð° Ð²ÑÐµÑ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½ÑÑ ÑÐ¸Ð¿Ð¾Ð² Ð½Ð° ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² ÑÐ¸Ð¿Ð°.
// Ð ÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ° Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ Ð¿ÐµÑÐµÐ³ÑÑÐ¶ÐµÐ½Ð½Ð¾Ð¹ ÑÑÐ½ÐºÑÐ¸Ð¸ ÑÐ¿ÑÐ¾ÑÐ°ÐµÑ Ð·Ð°Ð´Ð°ÑÑ. Ð¢Ð¾Ð³Ð´Ð° Ð½Ðµ Ð¿ÑÐ¸Ð´ÐµÑÑÑ ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ Ð½Ð¾Ð²ÑÐµ Ð¸Ð¼ÐµÐ½Ð°:

function last3(coll: number[]): number;
function last3(coll: string[]): string;
// Ð¢ÑÑ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð´Ð»Ñ Ð²ÑÐµÑ Ð¾ÑÑÐ°Ð»ÑÐ½ÑÑ ÑÐ¸Ð¿Ð¾Ð²

function last3(coll: any[]): any {
  return coll[coll.length - 1];
}

// Ð ÑÐ»ÑÑÐ°Ðµ TypeScript Ð´Ð°Ð¶Ðµ Ð½Ðµ Ð±ÑÐ´ÐµÑ Ð´ÑÐ±Ð»Ð¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð»Ð¾Ð³Ð¸ÐºÐ°, Ð½Ð¾ ÑÑÐ¾ Ð¾ÑÐ¾Ð±ÐµÐ½Ð½Ð¾ÑÑÑ Ð¸Ð¼ÐµÐ½Ð½Ð¾ TypeScript. Ð Ð´ÑÑÐ³Ð¸Ñ ÑÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸ ÑÐ¸Ð¿Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÑ ÑÐ·ÑÐºÐ°Ñ Ð¿ÑÐ¸Ð´ÐµÑÑÑ Ð´ÑÐ±Ð»Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð¸ Ð»Ð¾Ð³Ð¸ÐºÑ.

// ÐÐ°ÐºÐ¾Ð¹ Ð±Ñ Ð²Ð°ÑÐ¸Ð°Ð½Ñ ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð¼Ñ Ð½Ðµ Ð²ÑÐ±ÑÐ°Ð»Ð¸, ÑÐ¾Ð±Ð»ÑÐ´Ð°ÑÑÑÑ Ð´Ð²Ðµ Ð²ÐµÑÐ¸:
// -- ÐÐ½Ð°ÑÐµÐ½Ð¸Ñ, Ð¿ÐµÑÐµÐ´Ð°Ð²Ð°ÐµÐ¼ÑÐµ Ð²Ð¾ Ð²Ð½ÑÑÑÑ, Ð½Ð¸ÐºÐ°Ðº Ð½Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑÑÑÑ. ÐÐ½Ð¸ ÑÐ¾Ð»ÑÐºÐ¾ Ð¿ÐµÑÐµÐºÐ»Ð°Ð´ÑÐ²Ð°ÑÑÑÑ Ð¸Ð· Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¼ÐµÑÑÐ° Ð² Ð´ÑÑÐ³Ð¾Ðµ
// -- ÐÐ¾Ð³Ð¸ÐºÐ° ÑÐ°Ð±Ð¾ÑÑ Ð²ÑÐµÐ³Ð´Ð° Ð¾ÑÑÐ°ÐµÑÑÑ Ð¾Ð´Ð½Ð¾Ð¹ Ð¸ ÑÐ¾Ð¹ Ð¶Ðµ. Ð£ÑÐ»Ð¾Ð²Ð½ÑÐµ ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ð¸ Ð¿Ð¾ ÑÐ¸Ð¿Ñ Ð´Ð°Ð½Ð½ÑÑ Ð¾ÑÑÑÑÑÑÐ²ÑÑÑ

// Ð Computer Science ÑÐ²Ð¾Ð¹ÑÑÐ²Ð¾ ÑÑÐ½ÐºÑÐ¸Ð¸, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑÐµÐµ Ð¾Ð±ÑÐ°Ð±Ð°ÑÑÐ²Ð°ÑÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ ÑÐ°Ð·Ð½ÑÑ ÑÐ¸Ð¿Ð¾Ð² Ð¾Ð´Ð½Ð¸Ð¼ ÑÐ¿Ð¾ÑÐ¾Ð±Ð¾Ð¼ (Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑ Ð¾Ð´Ð¸Ð½ Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼), Ð½Ð°Ð·ÑÐ²Ð°ÐµÑÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸ÑÐµÑÐºÐ¸Ð¼ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾ÑÑÐ¸Ð·Ð¼Ð¾Ð¼. Ð¢Ð¾ ÐµÑÑÑ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸ â ÑÑÐ¾ ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸ÑÐµÑÐºÐ¾Ð³Ð¾ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾ÑÑÐ¸Ð·Ð¼Ð° Ð² TypeScript.

// ÐÐ°ÑÐ°Ð¼ÐµÑÑÐ¸ÑÐµÑÐºÐ¸Ð¹ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾ÑÑÐ¸Ð·Ð¼ Ð¸Ð³ÑÐ°ÐµÑ Ð²Ð°Ð¶Ð½ÑÑ ÑÐ¾Ð»Ñ Ð² ÑÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸ ÑÐ¸Ð¿Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÑ ÑÐ·ÑÐºÐ°Ñ ÑÐ°Ð¼, Ð³Ð´Ðµ Ð¿ÑÐ¸ÑÐ¾Ð´Ð¸ÑÑÑ ÑÐ²Ð½Ð¾ ÑÐºÐ°Ð·ÑÐ²Ð°ÑÑ ÑÐ¸Ð¿Ñ Ñ ÑÑÐ½ÐºÑÐ¸Ð¹. ÐÐ½ ÐµÑÑÑ Ð¿Ð¾ÑÑÐ¸ Ð²Ð¾ Ð²ÑÐµÑ Ð²ÑÑÐ¾ÐºÐ¾ÑÑÐ¾Ð²Ð½ÐµÐ²ÑÑ ÑÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸ ÑÐ¸Ð¿Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÑ ÑÐ·ÑÐºÐ°Ñ. Ð Java Ð¸ C# ÑÑÐ¾ ÑÐ¾Ð¶Ðµ Ð½Ð°Ð·ÑÐ²Ð°ÐµÑÑÑ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ°Ð¼Ð¸. Ð C++ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ ÑÐ°Ð±Ð»Ð¾Ð½Ñ, Ð½Ð¾ ÑÐ¼ÑÑÐ» Ð¾Ñ ÑÑÐ¾Ð³Ð¾ Ð½Ðµ Ð¼ÐµÐ½ÑÐµÑÑÑ, ÑÐ¾ÑÑ ÑÐ°Ð±Ð»Ð¾Ð½Ñ Ð² Ð¡++ â ÑÑÐ¾ Ð±Ð¾Ð»ÑÑÐµ, ÑÐµÐ¼ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¸ÑÐµÑÐºÐ¸Ð¹ Ð¿Ð¾Ð»Ð¸Ð¼Ð¾ÑÑÐ¸Ð·Ð¼.

// Ð Ð¿ÑÐ¾ÑÐ¸Ð²Ð¾Ð²ÐµÑ ÑÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸ ÑÐ¸Ð¿Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐ¼ ÑÐ·ÑÐºÐ°Ð¼ Ð² ÑÐ·ÑÐºÐ°Ñ Ñ Ð´Ð¸Ð½Ð°Ð¼Ð¸ÑÐµÑÐºÐ¾Ð¹ ÑÐ¸Ð¿Ð¸Ð·Ð°ÑÐ¸ÐµÐ¹, ÑÐ°ÐºÐ¸Ñ ÐºÐ°Ðº JavaScript, Python, Ruby, PHP, Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸ Ð½Ðµ Ð½ÑÐ¶Ð½Ñ. Ð Ð¿Ð¾Ð´Ð¾Ð±Ð½ÑÑ ÑÐ·ÑÐºÐ°Ñ Ð»ÑÐ±Ð¾Ð¹ Ð¾Ð±Ð¾Ð±ÑÐµÐ½Ð½ÑÐ¹ Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ Ð´Ð»Ñ Ð²ÑÐµÑ ÑÐ¸Ð¿Ð¾Ð² Ð´Ð°Ð½Ð½ÑÑ.

// ÐÐ°Ð´Ð°Ð½Ð¸Ðµ
// Ð ÐµÐ°Ð»Ð¸Ð·ÑÐ¹ÑÐµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¾Ð±Ð¾ÑÐµÐ½Ð½Ð¾Ð³Ð¾ ÑÐ¸Ð¿Ð° MyArray, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÑÐµÑ Ð°Ð½Ð°Ð»Ð¾Ð³ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸Ð· JavaScript. ÐÑÐ¸Ð¼ÐµÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¾Ð±ÑÐµÐºÑÐ° ÑÑÐ¾Ð³Ð¾ ÑÐ¸Ð¿Ð°:

// const coll: MyArray<number> = ...;
// coll.push(1); // 1
// coll.push(10); // 2
// coll.push(99); // 3

// const newColl = coll.filter((value) => value % 2 == 0);
// console.log(newColl.items); // [10]

// Ð¢Ð¸Ð¿ Ð²ÐºÐ»ÑÑÐ°ÐµÑ Ð² ÑÐµÐ±Ñ Ð´Ð²Ð° Ð¼ÐµÑÐ¾Ð´Ð°: push() Ð¸ filter(), ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÑÑÐ¸Ðµ Ð¿Ð¾ ÑÐ¸Ð³Ð½Ð°ÑÑÑÐµ Ñ Ð¼ÐµÑÐ¾Ð´Ð°Ð¼Ð¸ Array. ÐÐ°Ð½Ð½ÑÐµ Ð²Ð½ÑÑÑÐ¸ Ð´Ð¾Ð»Ð¶Ð½Ñ ÑÑÐ°Ð½Ð¸ÑÑÑÑ Ð² ÑÐ²Ð¾Ð¹ÑÑÐ²Ðµ items. ÐÐ»Ñ push() Ð¿ÑÐ¸Ð¼ÐµÐ¼ ÑÐ¾Ð³Ð»Ð°ÑÐµÐ½Ð¸Ðµ, ÑÑÐ¾ Ð¼ÐµÑÐ¾Ð´ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ ÑÐ¾Ð»ÑÐºÐ¾ Ð¾Ð´Ð¸Ð½ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ. ÐÐ³Ð½Ð¾ÑÐ¸ÑÑÐ¹ÑÐµ Ð¾ÑÑÐ°Ð»ÑÐ½ÑÐµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ.

type MyArray<T> = {
  items: Array<T>;
  push(value: T): number;
  filter(
    callback: (value: T, index: number, array: Array<T>) => boolean
  ): MyArray<T>;
};

// ---------> 47 tasks ---> Generics with multiple parameters

// ÐÐ¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸, ÐºÐ°Ðº Ð¸ Ð¾Ð±ÑÑÐ½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸, Ð¼Ð¾Ð³ÑÑ Ð¸Ð¼ÐµÑÑ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² ÑÐ¸Ð¿Ð°.
// ÐÑÐ¸Ð½ÑÐ¸Ð¿ ÑÐ°Ð±Ð¾ÑÑ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¾Ð² Ð¾Ñ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð° Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² Ð½Ðµ Ð¼ÐµÐ½ÑÐµÑÑÑ. ÐÐ´Ð¸Ð½ÑÑÐ²ÐµÐ½Ð½Ð¾Ðµ, Ð·Ð° ÑÐµÐ¼ Ð½ÑÐ¶Ð½Ð¾ ÑÐ»ÐµÐ´Ð¸ÑÑ, ÑÑÐ¾ Ð¸Ð¼ÐµÐ½Ð°:

type Double<T, U> = {
  first: T;
  second: U;
};

const value: Double<string, number> = {
  first: 'code-basics',
  second: 1,
};

// ÐÑÐ²Ð¾Ð´ ÑÐ¸Ð¿Ð° Ð¸Ð· Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ¾Ð² ÑÑÐ½ÐºÑÐ¸Ð¸
// ÐÑÐµÐ´ÑÑÐ°Ð²Ð¸Ð¼, ÑÑÐ¾ Ð½Ð°Ð¼ Ð½ÑÐ¶Ð½Ð¾ Ð²ÑÐ·Ð²Ð°ÑÑ ÑÑÐ½ÐºÑÐ¸Ñ Ñ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¸Ð¼Ð¸ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°Ð¼Ð¸. ÐÑÐ³ÑÐ¼ÐµÐ½ÑÑ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÐµÐ½Ñ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ°Ð¼Ð¸.
// ÐÐ°Ð¿ÑÐ¸Ð¼ÐµÑ, ÑÑÐ½ÐºÑÐ¸Ñ join() Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð° ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:

function join1<T, U>(coll1: (T | U)[], coll2: U[]): (T | U)[] {
  return coll1.concat(coll2);
}

join1<number, string>([1, 2], ['one', 'two']); // [1, 2, 'one', 'two']

// ÐÐ¾ TypeScript Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ Ð½Ð°Ð¼ ÑÐ´ÐµÐ»Ð°ÑÑ ÑÑÐ¾ Ð¿ÑÐ¾ÑÐµ Ð¸ Ð½Ðµ ÑÐºÐ°Ð·ÑÐ²Ð°ÑÑ ÑÐ¸Ð¿Ñ Ð´Ð»Ñ Ð²ÑÐµÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð²:

join1([1, 2], ['one', 'two']); // [1, 2, 'one', 'two']

// TypeScript ÑÐ°Ð¼ Ð²ÑÐ²ÐµÐ´ÐµÑ ÑÐ¸Ð¿Ñ Ð´Ð»Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² ÑÑÐ½ÐºÑÐ¸Ð¸. Ð­ÑÐ¾ Ð½Ð°Ð·ÑÐ²Ð°ÐµÑÑÑ Ð²ÑÐ²Ð¾Ð´Ð¾Ð¼ ÑÐ¸Ð¿Ð° Ð¸Ð· Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ¾Ð² ÑÑÐ½ÐºÑÐ¸Ð¸. Ð Ð´Ð°Ð½Ð½Ð¾Ð¼ ÑÐ»ÑÑÐ°Ðµ TypeScript Ð²ÑÐ²ÐµÐ´ÐµÑ ÑÐ¸Ð¿Ñ number Ð¸ string Ð´Ð»Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² T Ð¸ U ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÐµÐ½Ð½Ð¾.

// Ð ÑÐ»ÐµÐ´ÑÑÑÐ¸Ñ ÑÑÐ¾ÐºÐ°Ñ Ð¼Ñ Ð¿Ð¾Ð·Ð½Ð°ÐºÐ¾Ð¼Ð¸Ð¼ÑÑ ÑÐ¾ Ð²ÑÑÑÐ¾ÐµÐ½Ð½ÑÐ¼Ð¸ Ð² TypeScript Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ°Ð¼Ð¸, Ñ ÐºÐ¾ÑÐ¾ÑÑÑ Ð´Ð²Ð° Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°. Ð ÑÐµÐ°Ð»ÑÐ½Ð¾Ð¼ Ð¶Ðµ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ð¸ ÑÐ°ÐºÐ¸Ðµ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¸ ÑÐ°ÑÑÐ¾ Ð²ÑÑÑÐµÑÐ°ÑÑÑÑ Ð² Ð¿ÑÐ¸ÐºÐ»Ð°Ð´Ð½Ð¾Ð¼ ÐºÐ¾Ð´Ðµ, Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ, Ð² React.

// -> ÐÐ°Ð´Ð°Ð½Ð¸Ðµ
// Ð ÐµÐ°Ð»Ð¸Ð·ÑÐ¹ÑÐµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¾Ð±Ð¾Ð±ÑÐµÐ½Ð½Ð¾Ð³Ð¾ ÑÐ¸Ð¿Ð° MyMap, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÑÐµÑ Ð¸Ð· ÑÐµÐ±Ñ Ð°Ð½Ð°Ð»Ð¾Ð³ Ð°ÑÑÐ¾ÑÐ¸Ð°ÑÐ¸Ð²Ð½Ð¾Ð³Ð¾ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸Ð· JavaScript. ÐÑÐ¸Ð¼ÐµÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¾Ð±ÑÐµÐºÑÐ° ÑÑÐ¾Ð³Ð¾ ÑÐ¸Ð¿Ð°:

// const map: MyMap<string, number> = ...;
// map.set('one', 1);
// map.set('two', 2);

// map.get('one'); // 1
// map.get('two'); // 2

// Ð¢Ð¸Ð¿ Ð²ÐºÐ»ÑÑÐ°ÐµÑ Ð² ÑÐµÐ±Ñ Ð´Ð²Ð° Ð¼ÐµÑÐ¾Ð´Ð° set() Ð¸ get(). ÐÐµÑÐ²ÑÐ¹ Ð¼ÐµÑÐ¾Ð´ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ Ð´Ð²Ð° Ð´Ð¶ÐµÐ½ÐµÑÐ¸Ðº-Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°: ÐºÐ»ÑÑ Ð¸ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ. ÐÑÐ¾ÑÐ¾Ð¹ Ð¼ÐµÑÐ¾Ð´ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ ÐºÐ»ÑÑ Ð¸ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ. ÐÐ½Ð°ÑÐµÐ½Ð¸Ñ ÑÑÐ°Ð½ÑÑÑÑ Ð²Ð½ÑÑÑÐ¸ Ð¾Ð±ÑÐµÐºÑÐ° Ð² Ð²Ð¸Ð´Ðµ Ð²ÑÑÑÐ¾ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð² JavaScript ÐºÐ»Ð°ÑÑÐ° Map().

type MyMap<K, V> = {
  values: Map<K, V>;
  set(key: K, value: V): void;
  get(key: K): V | undefined;
};

// ---------> 48 tasks ---> Asynchronous functions

// Promise ÑÑÐ°Ð»Ð¸ ÑÐ°Ð¼ÑÐ¼ Ð¿Ð¾Ð¿ÑÐ»ÑÑÐ½ÑÐ¼ ÑÐ¿Ð¾ÑÐ¾Ð±Ð¾Ð¼ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð°ÑÐ¸Ð½ÑÑÐ¾Ð½Ð½ÑÐ¼ ÐºÐ¾Ð´Ð¾Ð¼ Ð² JavaScript. ÐÐ½Ð¸ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ callback hell, Ð° ÑÐ°ÐºÐ¶Ðµ ÑÐ¿ÑÐ¾ÑÐ°ÑÑ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð°ÑÐ¸Ð½ÑÑÐ¾Ð½Ð½ÑÐ¼Ð¸ ÑÑÐ½ÐºÑÐ¸ÑÐ¼Ð¸. TypeScript ÑÐ°ÐºÐ¶Ðµ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÐµÑ Ð¿ÑÐ¸Ð²ÑÑÐ½ÑÐ¹ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸Ñ Ð´Ð»Ñ ÑÐ°Ð±Ð¾ÑÑ Ñ Promise Ð² Ð²Ð¸Ð´Ðµ async/await Ð¸ ÑÐ¸Ð¿Ð¸Ð·Ð°ÑÐ¸Ñ.

const promise = new Promise<number>((resolve, _) => {
  setTimeout(() => {
    resolve(42);
  }, 1000);
});

// Promise Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÑÐµÑ ÑÐ¾Ð±Ð¾Ð¹ Ð´Ð¶ÐµÐ½ÐµÑÐ¸Ðº Ñ ÑÐ¸Ð¿Ð¾Ð¼, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð±ÑÐ´ÐµÑ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐµÐ½ Ð² ÑÐ»ÑÑÐ°Ðµ ÑÑÐ¿ÐµÑÐ½Ð¾Ð³Ð¾ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ. Ð Ð¿ÑÐ¸Ð¼ÐµÑÐµ Ð²ÑÑÐµ ÑÑÐ¾ ÑÐ¸Ð¿ number.

// Ð§ÑÐ¾Ð±Ñ Ð¿ÑÐ¾Ð´Ð¾Ð»Ð¶Ð°ÑÑ ÑÐ°Ð±Ð¾ÑÐ°ÑÑ Ð² Ð¾Ð´Ð½Ð¾Ð¼ ÑÑÐ¸Ð»Ðµ Ñ ÑÑÐ½ÐºÑÐ¸ÑÐ¼Ð¸, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÑÑ callback, Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¿ÑÐ¾Ð¼Ð¸ÑÐ¸ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¸Ñ. ÐÐ»Ñ ÑÑÐ¾Ð³Ð¾ Ð½Ð°Ð¼ Ð½ÑÐ¶Ð½Ð¾ Ð¾Ð±ÐµÑÐ½ÑÑÑ ÑÑÐ½ÐºÑÐ¸Ñ Ð² Promise:

const wait = (ms: number): Promise<number> => {
  return new Promise(resolve => {
    const timer = setTimeout(() => {
      resolve(ms);
    }, ms);
  });
};

// ÐÑ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¸ Ð½Ðµ Ð¾Ð¿Ð¸ÑÑÐ²Ð°ÑÑ ÑÐ¸Ð¿ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼Ð¾Ð³Ð¾ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ, ÑÐ°Ðº ÐºÐ°Ðº TypeScript ÑÐ¼Ð¾Ð¶ÐµÑ ÐµÐ³Ð¾ Ð²ÑÐ²ÐµÑÑÐ¸ Ð¸Ð· ÑÐ¸Ð¿Ð°, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¼Ñ Ð¿ÐµÑÐµÐ´Ð°ÐµÐ¼ Ð² Promise. Ð ÑÐ¾Ð¼Ñ Ð¶Ðµ Ð¸Ð· ÑÑÐ½ÐºÑÐ¸Ð¸, ÐºÐ¾ÑÐ¾ÑÐ°Ñ Ð¿Ð¾Ð¼ÐµÑÐµÐ½Ð° ÐºÐ°Ðº async, Promise Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑÑÑ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸, Ð¸ ÑÐ¸Ð¿ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼Ð¾Ð³Ð¾ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð±ÑÐ´ÐµÑ Ð¾Ð±ÐµÑÐ½ÑÑ Ð² Promise:

const getHours = async () => {
  return new Date().getHours();
};

const hoursPromise: Promise<number> = getHours();

// Ð¢Ð°Ðº ÐºÐ°Ðº Promise, ÐºÐ°Ðº Ð¸ ÐºÐ¾Ð½ÑÐµÐ¹Ð½ÐµÑ, Ð·Ð°Ð²Ð¾ÑÐ°ÑÐ¸Ð²Ð°ÐµÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð²Ð½ÑÑÑÐ¸ ÑÐµÐ±Ñ, Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ await Ð´Ð»Ñ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð¸Ð· Ð½ÐµÐ³Ð¾:

const hours = await getHours();

// Ð TypeScript await Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ ÑÐ°Ðº Ð¶Ðµ, ÐºÐ°Ðº Ð² JavaScript.

// Promise Ð²Ð¼ÐµÑÑÐµ Ñ async/await Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑ Ð¿Ð¸ÑÐ°ÑÑ Ð°ÑÐ¸Ð½ÑÑÐ¾Ð½Ð½ÑÐ¹ ÐºÐ¾Ð´ Ð² ÑÐ¸Ð½ÑÑÐ¾Ð½Ð½Ð¾Ð¼ ÑÑÐ¸Ð»Ðµ Ð¸ ÑÐ¸Ð»ÑÐ½Ð¾ ÑÐ¿ÑÐ¾ÑÐ°ÑÑ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð°ÑÐ¸Ð½ÑÑÐ¾Ð½Ð½ÑÐ¼ ÐºÐ¾Ð´Ð¾Ð¼. TypeScript Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÐµÑ ÑÑÐ¾Ñ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸Ñ Ð¸ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ Ð´Ð¶ÐµÐ½ÐµÑÐ¸ÐºÐ¾Ð² Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ Ð½Ð°Ð¼ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÐµÐ³Ð¾ ÑÐ¾ Ð²ÑÐµÐ¹ Ð¼Ð¾ÑÑÑ ÑÐ¸Ð¿Ð¸Ð·Ð°ÑÐ¸Ð¸.

// ÐÐ°Ð´Ð°Ð½Ð¸Ðµ
// Ð ÐµÐ°Ð»Ð¸Ð·ÑÐ¹ÑÐµ Ð°ÑÐ¸Ð½ÑÑÐ¾Ð½Ð½ÑÐ¹ Ð²Ð°ÑÐ¸Ð°Ð½Ñ ÑÑÐ½ÐºÑÐ¸Ð¸ map() - asyncMap(). ÐÐµÑÐ²ÑÐ¼ Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ¾Ð¼ asyncMap() Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ Ð¼Ð°ÑÑÐ¸Ð² Ñ Promise. ÐÑÐ¾ÑÑÐ¼ â ÑÑÐ½ÐºÑÐ¸Ñ, ÐºÐ¾ÑÐ¾ÑÐ°Ñ Ð¿ÑÐ¸Ð¼ÐµÐ½ÑÐµÑÑÑ Ðº ÐºÐ°Ð¶Ð´Ð¾Ð¼Ñ ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ. Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð¾Ð»Ð¶Ð½Ð° Ð²ÐµÑÐ½ÑÑÑ Ð¼Ð°ÑÑÐ¸Ð² Ñ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ°Ð¼Ð¸ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ°:

const asyncMap = async <T, P>(
  arr: Promise<T>[],
  fn: (item: T, index: number) => P
) => {
  const promises = arr.map(async (item, index) => {
    const result = await item;
    return fn(result, index);
  });

  return Promise.all(promises);
};

const promisedNumbers = [
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.resolve(3),
];

asyncMap(promisedNumbers, (num, index) => num * index).then(result => {
  console.log(result); // [0, 2, 6]
});

// ---------> 49 tasks ---> Generics in the classes

// ÐÐ¶ÐµÐ½ÐµÑÐ¸Ðº-ÐºÐ»Ð°ÑÑÑ, ÐºÐ°Ðº Ð¸ Ð´Ð¶ÐµÐ½ÐµÑÐ¸Ðº ÑÑÐ½ÐºÑÐ¸Ð¸, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑ ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ ÐºÐ»Ð°ÑÑÑ, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð¼Ð¾Ð³ÑÑ ÑÐ°Ð±Ð¾ÑÐ°ÑÑ Ñ ÑÐ°Ð·Ð½ÑÐ¼Ð¸ ÑÐ¸Ð¿Ð°Ð¼Ð¸ Ð´Ð°Ð½Ð½ÑÑ. ÐÐ°Ð¿ÑÐ¸Ð¼ÐµÑ, ÐºÐ»Ð°ÑÑ Triple Ð¼Ð¾Ð¶ÐµÑ ÑÑÐ°Ð½Ð¸ÑÑ ÑÑÐ¸ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð»ÑÐ±Ð¾Ð³Ð¾ ÑÐ¸Ð¿Ð°. Ð ÑÑÐ¾Ð¼ ÑÐ»ÑÑÐ°Ðµ Ð²Ð¼ÐµÑÑÐ¾ ÑÐ¾Ð³Ð¾, ÑÑÐ¾Ð±Ñ ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ ÐºÐ»Ð°ÑÑÑ Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ ÑÐ¸Ð¿Ð°, Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð·Ð´Ð°ÑÑ Ð¾Ð±Ð¾Ð±ÑÐµÐ½Ð½ÑÐ¹ ÐºÐ»Ð°ÑÑ, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð±ÑÐ´ÐµÑ ÑÐ°Ð±Ð¾ÑÐ°ÑÑ Ñ Ð»ÑÐ±ÑÐ¼ ÑÐ¸Ð¿Ð¾Ð¼ Ð´Ð°Ð½Ð½ÑÑ.

class Triple<T, U, V> {
  constructor(protected first: T, protected second: U, protected third: V) {}

  getFirst(): T {
    return this.first;
  }

  getSecond(): U {
    return this.second;
  }

  getThird(): V {
    return this.third;
  }
}

// Ð ÑÑÐ¾Ð¼ Ð¿ÑÐ¸Ð¼ÐµÑÐµ ÐºÐ»Ð°ÑÑ Triple â Ð´Ð¶ÐµÐ½ÐµÑÐ¸Ðº-ÐºÐ»Ð°ÑÑ, Ð² ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¿Ð¾Ð¼ÐµÑÑÐ¸ÑÑ Ð»ÑÐ±ÑÐµ ÑÐ¸Ð¿Ñ Ð´Ð°Ð½Ð½ÑÑ. ÐÑÐ¸ ÑÑÐ¾Ð¼ Ñ Ð½Ð°Ñ Ð¾ÑÑÐ°ÑÑÑÑ Ð³Ð°ÑÐ°Ð½ÑÐ¸Ð¸ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑÐ¸ Ð¸ Ð²ÑÐ²Ð¾Ð´ ÑÐ¸Ð¿Ð¾Ð², ÐºÐ¾ÑÐ¾ÑÑÐµ Ð¼Ñ Ð¿Ð¾Ð»ÑÑÐ¸Ð»Ð¸ Ð¿ÑÐ¸ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ð¸ Ð¾Ð±Ð¾Ð±ÑÐµÐ½Ð½ÑÑ ÑÑÐ½ÐºÑÐ¸Ð¹:

const triple = new Triple(1, 'string', null);
const firstItem = triple.getFirst(); // number
const secondItem = triple.getSecond(); // string

// Ð¢Ð°ÐºÐ¶Ðµ Ð¼Ð¾Ð¶Ð½Ð¾ Ð½Ð°ÑÐ»ÐµÐ´Ð¾Ð²Ð°ÑÑÑÑ Ð¾Ñ Ð¾Ð±Ð¾Ð±ÑÐµÐ½Ð½ÑÑ ÐºÐ»Ð°ÑÑÐ¾Ð². ÐÐ°Ð¿ÑÐ¸Ð¼ÐµÑ, ÐºÐ»Ð°ÑÑ Pair Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð½Ð°ÑÐ»ÐµÐ´Ð½Ð¸ÐºÐ¾Ð¼ ÐºÐ»Ð°ÑÑÐ° Triple, ÐºÐ¾ÑÐ¾ÑÑÐ¹ ÑÑÐ°Ð½Ð¸Ñ Ð´Ð²Ð° Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð»ÑÐ±Ð¾Ð³Ð¾ ÑÐ¸Ð¿Ð°:

class Pair<T, U> extends Triple<T, U, never> {
  constructor(first: T, second: U) {
    super(first, second, undefined as never);
  }

  getFirst(): T {
    return this.first;
  }

  getSecond(): U {
    return this.second;
  }
}

// ÐÐ´ÐµÑÑ Ð¼Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð»Ð¸ Ð¿ÑÐ¸Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ Ðº ÑÐ¸Ð¿Ñ never, ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð¼ÐµÑÐ¸ÑÑ ÑÑÐµÑÐ¸Ð¹ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ ÐºÐ°Ðº Ð¾ÑÑÑÑÑÑÐ²ÑÑÑÐ¸Ð¹.

// ÐÐ°Ðº Ð¸ Ð¾Ð±ÑÑÐ½ÑÐµ ÐºÐ»Ð°ÑÑÑ, Ð¾Ð±Ð¾Ð±ÑÐµÐ½Ð½ÑÐµ ÐºÐ»Ð°ÑÑÑ ÑÐ°ÐºÐ¶Ðµ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð² ÐºÐ°ÑÐµÑÑÐ²Ðµ ÑÐ¸Ð¿Ð¾Ð² Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² ÑÑÐ½ÐºÑÐ¸Ð¹:

function swap<T, U>(pair: Pair<T, U>): Pair<U, T> {
  return new Pair(pair.getSecond(), pair.getFirst());
}

// ÐÐ¶ÐµÐ½ÐµÑÐ¸Ðº-ÐºÐ»Ð°ÑÑÑ Ð¿Ð¾Ð»ÐµÐ·Ð½Ñ, ÐºÐ¾Ð³Ð´Ð° Ð½Ð°Ð¼ Ð½ÑÐ¶Ð½Ð¾ ÑÐ¾Ð·Ð´Ð°ÑÑ ÐºÐ°ÐºÐ¾Ð¹-Ð½Ð¸Ð±ÑÐ´Ñ ÐºÐ¾Ð½ÑÐµÐ¹Ð½ÐµÑ Ð´Ð»Ñ ÑÑÐ°Ð½ÐµÐ½Ð¸Ñ Ð´Ð°Ð½Ð½ÑÑ, ÐºÐ°Ðº Ð² Ð¿ÑÐ¸Ð¼ÐµÑÐµ Ñ ÐºÐ»Ð°ÑÑÐ¾Ð¼ Pair. Array, Map, Set â ÑÑÐ¾ Ð´Ð¶ÐµÐ½ÐµÑÐ¸Ðº-ÐºÐ»Ð°ÑÑÑ, ÐºÐ¾ÑÐ¾ÑÑÐµ ÑÑÐ°Ð½ÑÑ ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ Ð·Ð°Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐ¸Ð¿Ð°.

// ÐÐ°Ð´Ð°Ð½Ð¸Ðµ
// Ð ÐµÐ°Ð»Ð¸Ð·ÑÐ¹ÑÐµ ÐºÐ»Ð°ÑÑ Ð¾ÑÐµÑÐµÐ´Ð¸ (Queue) Ñ Ð¼ÐµÑÐ¾Ð´Ð°Ð¼Ð¸ enqueue Ð¸ dequeue. ÐÐµÑÐ¾Ð´ enqueue Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ ÑÐ»ÐµÐ¼ÐµÐ½Ñ Ð² ÐºÐ¾Ð½ÐµÑ Ð¾ÑÐµÑÐµÐ´Ð¸, Ð° Ð¼ÐµÑÐ¾Ð´ dequeue ÑÐ´Ð°Ð»ÑÐµÑ ÑÐ»ÐµÐ¼ÐµÐ½Ñ Ð¸Ð· Ð½Ð°ÑÐ°Ð»Ð° Ð¾ÑÐµÑÐµÐ´Ð¸. ÐÑÐ»Ð¸ Ð¾ÑÐµÑÐµÐ´Ñ Ð¿ÑÑÑÐ°, ÑÐ¾ Ð¿ÑÐ¸ Ð²ÑÐ·Ð¾Ð²Ðµ Ð¼ÐµÑÐ¾Ð´Ð° dequeue Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ Ð²ÑÐ±ÑÐ¾ÑÐµÐ½Ð¾ Ð¸ÑÐºÐ»ÑÑÐµÐ½Ð¸Ðµ Error:

class Queue<T> {
  private queue: Array<T> = [];

  constructor() {}
  enqueue(item: T): void {
    this.queue.push(item);
  }
  dequeue(): T | Error {
    const result = this.queue.shift();
    if (result) {
      return result;
    } else {
      throw new Error('Queue is empty');
    }
  }
}

const queue = new Queue<number>();
queue.enqueue(1);
queue.dequeue(); // 1
queue.dequeue(); // Error: Queue is empty
